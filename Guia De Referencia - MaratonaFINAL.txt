/*******Guia de Referencia - UNITAU **********//
//**********************************************
//QuickSort O(N log N) worst case O(n^2)
#include <iostream>
#include <vector>

using namespace std;

#define MAXN 10000

int n, a[MAXN];
void quicksort(int lo, int hi) {
    int i=lo, j=hi, h;

    int x=a[(lo+hi)/2];

    do {
        while (a[i]<x) i++;
        while (a[j]>x) j--;
        if (i<=j) {
            swap(a[i], a[j]);
            i++;
            j--;
        }
    } while (i<=j);

    if (lo<j) quicksort(lo, j);
    if (i<hi) quicksort(i, hi);
}
//**********************************************
//Merge-Sort O(N log N)
vector<int> merge(vector<int>& b, vector<int>& c) {
	vector<int> a;

	while(!b.empty() && !c.empty()) {
		if(*b.begin() < *c.begin()) {
			a.push_back(*b.begin());
			b.erase(b.begin());
		} else if(*b.begin() > *c.begin()) {
			a.push_back(*c.begin());
			c.erase(c.begin());
		} else {
			a.pb(*b.begin());
			a.pb(*c.begin());
			b.erase(b.begin());
			c.erase(c.begin());
		}
	}
	while(!b.empty()) { a.pb(*b.begin()); b.erase(b.begin()); }
	while(!c.empty()) { a.pb(*c.begin()); c.erase(c.begin()); }
	return a;
}

vector<int> mergeSort(vector<int>& a) {
	if(sz(a) <= 1) {
		return a;
	}
	vector<int> b;
	vector<int> c;

	for(int i = 0; i < sz(a) / 2; i++) {
		b.pb(a[i]);
	}
	for(int i = sz(a) / 2; i < sz(a); i++) {
		c.pb(a[i]);
	}
	vector<int> sb = mergeSort(b);
	vector<int> sc = mergeSort(c);
	return merge(sb, sc);
}
//**********************************************
//Heapsort O(N log N)
#include <iostream>
#include <vector>

using namespace std;

#define MAXN 10000

int n, a[MAXN];

void downheap(int v) {
    int w = 2*v+1;
    while (w < n) {
        if(w + 1 < n) {
            if (a[w+1]>a[w]) w++;
        }
        if(a[v] >= a[w]) return;
        swap(a[v], a[w]);
        v = w;
        w = 2*v+1;
    }
}

void buildheap() {
    for (int v = n/2-1; v >= 0; v--) {
        downheap(v);
    }
}

void heapsort() {
    buildheap();
    while (n > 1) {
        n--;
        swap(a[0], a[n]);
        downheap(0);
    }
}

//**********************************************
//Merge contando inversões
int merge(int arr[], int temp[], int left, int mid, int right);
 
int _mergeSort(int arr[], int temp[], int left, int right) {
	int mid, inv_count = 0;
	if (right > left) {
		mid = (right + left)/2;
		inv_count = _mergeSort(arr, temp, left, mid);
		inv_count += _mergeSort(arr, temp, mid+1, right);
		inv_count += merge(arr, temp, left, mid+1, right);
	}
	return inv_count;
}

int mergeSort(int arr[], int array_size) {
	int *temp = (int*) malloc(sizeof(int)*array_size);
	return _mergeSort(arr, temp, 0, array_size - 1);
}
 
int merge(int arr[], int temp[], int left, int mid, int right) {
	int i, j, k;
	int inv_count = 0;
 
	i = left;
	j = mid;
	k = left;
	while ((i <= mid - 1) && (j <= right)) {
		if (arr[i] <= arr[j]) {
			temp[k++] = arr[i++];
		} else {
			temp[k++] = arr[j++];
			inv_count = inv_count + (mid - i);
		}
	}
	
	while (i <= mid - 1) {
		temp[k++] = arr[i++];
	}
	
	while (j <= right) {
		temp[k++] = arr[j++];
	}

	for (i = left; i <= right; i++) {
		arr[i] = temp[i];
	}
	
	return inv_count;
}
//**********************************************
//**********************************************
Kadade 2D simplificaco
int best = 0;
for(int i = 1; i <= n; i++){
  for(int j = i; j <= n; j++){
    int tmp = 0;
    for(int k = 1; k <= n; k++){
      tmp += (freq[j][k] - freq[i-1][k]);
      best = max(tmp, best);
      if(tmp < 0){
       tmp = 0;
      }
    }
  }
}
//////////////////////////////////////////////////////////
//Kadane 2D
for (int i = 1; i <= N; i++) {
	for (int j = 1; j <= N; j++) {
		cin >> M[i][j];
	}
	for (int j = 1; j <= N; j++) {
		dp[i][j] = dp[i][j - 1] + M[i][j];
	}
 }

int ans = -INT_MAX / 3;
for (int i = 1; i <= N; i++) {
	for (int j = i; j <= N; j++) {
		int sum = 0;
		for (int k = 1; k <= N; k++) {
			sum += dp[k][j] - dp[k][i - 1];
			chmax(ans, sum);
			if (sum < 0) sum = 0;
		}
	}
 }
//**********************************************
//Binary Search O(log n)
void search(int x) {
	int low = 0, high = INF, mid;

	while(low < high) {
		mid = low + (high - low) / 2;
		if(satisfied) {
			//High bound
			low = mid + 1;
		} else {
			high = mid;
		}
	}
	return low;
}
//**********************************************
//Binary Search for Real Number O(log N)
void search(double x) {
	int low = 0, high = INF, mid;
	for(int i = 0; i <= 100; i++) {
		mid = low + (high - low) / 2;
		if(satisfied) {
			low = mid;
		} else {
			high = mid;
		}
	}
	return low;
}
//**********************************************
//Split empty spaces in string
void split(vector<string>& v, const string& s) {
    istringstream ss(s, istringstream::in);
    v.clear(); string t;
    while(ss >> t) {
        v.push_back(t);
    }
}
//**********************************************
//Knuth-Morris-Pratt O(n)
vector<int> KMP(string S, string K) {
    vector<int> T(K.size() + 1, -1);
    vector<int> matches;

    if(K.size() == 0) {
        matches.push_back(0);
        return matches;
    }
    for(int i = 1; i <= K.size(); i++) {
        int pos = T[i - 1];
        while(pos != -1 && K[pos] != K[i - 1]) pos = T[pos];
        T[i] = pos + 1;
    }

    int sp = 0;
    int kp = 0;
    while(sp < S.size()) {
        while(kp != -1 && (kp == K.size() || K[kp] != S[sp])) kp = T[kp];
        kp++;
        sp++;
        if(kp == K.size()) matches.push_back(sp - K.size());
    }

    return matches;
}
//**********************************************
//Suffix Array
#define max 100010

int delta, len, SA[max], iSA[max], val[max], tval[max];
char s[max];
bool cmp(const int& a, const int& b) {
    return val[a+delta] < val[b+delta];
}

void build_SA() {
    int i, j;
    for (i=0; i<len; i++) val[i] = s[i];
    for (i=0; i<len; i++) SA[i] = i;

    delta = 0;
    sort(SA, SA+len, cmp);

    for(delta = 1; ; delta *= 2) {
        bool found = false;
        for(i = 0; i < len; i++) {
            for(j = i + 1; j < len; j++) if(val[SA[i]] != val[SA[j]]) break;
            if (j > i+1) {
                found = true;
                sort(SA+i, SA+j, cmp);
            }
            i = j - 1;
        }

        if(!found) break;
        tval[SA[0]] = 0;
        for(i = 1; i < len; i++) {
            tval[SA[i]] = tval[SA[i-1]];
            if(val[SA[i]] == val[SA[i-1]] && val[SA[i]+delta] == val[SA[i-1]+delta]);
            else tval[SA[i]]++;
        }
        memcpy(val, tval, len * sizeof(int));
    }
}

build_SA();
for (int i = 0; i < len; i++) printf("%d\n", SA[i]);
/* ******************************* GRAPH ************************* */
//DFS
void dfs(int x) {
    vis[x] = 1;
    for(int i = 1; i <= n; i++) {
        if(vis[i] == 0 && matrix[x][i] == 1) dfs(i);
    }
}
//**********************************************
//BFS
void bfs(int x) {
	int dist[N], vis[N]; 
	memset(dist, 0, sizeof(dist)); 
	memset(vis, 0, sizeof(vis));
	
	queue<int> q;
	q.push(x);
	vis[x] = true;
	dist[x] = 0;

	while(!q.empty()) {
		int tmp = q.front(); q.pop();
		vis[tmp] = true;

		for(int i = 1; i <= N; i++) {
			if(!vis[i] && matrix[tmp][i]) {
				q.push(i);
				dist[i] = dist[tmp] + 1;
			}
		}
	}
}
//**********************************************
//Topological Sort (Recursive)
void dfs(int x) {
    used[x] = 1;
    for(int b = 0; b < g[x].size(); b++) {
        if(!used[g[x][b]]) dfs(g[x][b]);
    }
    order.push_back(x);
}
//**********************************************
//Topological Sort (Iterative) 
for (int i = 0; i < M; i++) {
	scanf("%d%d", &a, &b);
	graph[a].push_back(b);
	deg[b] += 1;
}
 
priority_queue<int, vector<int>, greater<int> > pq;
 
for (int i = 0; i < N; i++) {
	if(deg[i] == 0) {
		pq.push(i);
	}
 }
int on = 0;
while (!pq.empty()) {
	int now = pq.top(); 
	pq.pop();
	order.push_back(now);
	for (int i = 0; i < (int) graph[now].size(); i++) {
		int next = graph[now][i]; 
		deg[next] -= 1;
		
		if(deg[next] == 0) {
			pq.push(next);
		}
	}
 }
//**********************************************
//Ordenação topologica com checagem de ciclos: [OTCC]
//Se a variavel has se tornar verdade, o grafo contem um ciclo.
void dfs(int x) {
    vis[x] = 1;
    for(int u = 0; u < n; u++) {
        if(vis[u] == 1 && graph[x][u] == 1) has = true;
        if(vis[u] == 0 && graph[x][u] == 1) {
            dfs(u);
        }
    }
    vis[x] = 2;
    order.push_back(x);
}

//**********************************************
//Componentes fortemente conectados: [CFC]
Matrix ga -> Matrix original
Matrix gb -> Matrix transposta:

Primeiro Ordena-se topologicamente os vertices, depois faz-se a checagem da quantidade e componentes em um
componente fortemente conectado em um grafo direcionado:

void dfs1(int x) {
    used[x] = 1;
    for(int b = 0; b < g[x].size(); b++) {
        if(!used[g[x][b]]) dfs1(g[x][b]);
    }
4    order.push_back(x);
}

void dfs2(int x) {
    used[x] = 1;
	comoponent.insert(x);
    for(int b = 0; b < gr[x].size(); b++) {
        if(!used[gr[x][b]]) dfs2(gr[x][b]);
    }
}

//Ordenando Topologicamente
for(i = 1; i <= n; i++) if(!used[i]) dfs1(i);

//Procura pelos componentes:
for(i = 0; i < order.size(); i++) {
    int v = order[i];
	if(!used[v]) {
		dfs2(v);
        ans++;
        component.clear();
	}
}
//**********************************************
//Bellman Ford - O(v * e)
vector <pair<int, int> > edges;
int graph[MAXN][MAXN]; 
int dist[MAXN];

int N; 
bool bellman_ford(int s) {
	int M = edges.size();
	memset (dist, INF, sizeof(int)*n);
	dist[s] = 0;
	for (int k = 0; k < N-1; ++k) {
		for (int j = 0; j < M; ++j) {
			int u = edges[j].first;
			int v = edges[j].second;
			if (dist[u] < INF && dist[v] > dist[u] + graph[u][v])
				dist[v] = dist[u] + graph[u][v];
		}
	}
	//Negative Cycle
	for (int j = 0; j < m; ++j) {
		int u = edges[j].first, v = edges[j].second;
		if (dist[u] < INF && dist[v] > dist[u] + graph[u][v]) {
			return false;
		}
	}
	return true;
}
//********************************************
//Determinando se um grafo é bipartido ou não:
//Sendo 'gr' a matrix de adjacencia representando o Grafo.
bool dfs(int node, int c) {
    if(color[node] != 0) {
        if(color[node] == c) {
            return true;
        } else {
            return false;
        }
    }
    color[node] = c;
    for(int i = 1; i <= n; i++) 
		if(gr[node][i] == 1) {
			if(!dfs(i, -c)) {
				return false;
			}
        }
    }
    return true;
}
//1-based graph
dfs(1, 1);
//othewise
dfs(0, 1);

//******************************************
//Matrix Multiplication
//Can be used for various problems, but can number of paths in adjacency matrix is it's preferred use
vector<vector<int> > multiply(vector<vector<int> > a, vector<vector<int> > b) {
	vector<vector<int> > res(c, vector<int>(c));
	for(int i = 0; i < c; i++) {
		for(int j = 0; j < c; j++) {
			int sum = 0;
			for (int k = 0; k < c; k++) {
				sum |= a[i][k] & b[k][j];
			}
			res[i][j] = sum;
		}
	}
	return res;
}

vector<vector<int> > binPow(vector<vector<int> > a, int n) {
	if (n == 1) {
		return a;
	} else if ((n & 1) != 0) {
		return multiply(a, binPow(a, n - 1));
	} else {
		vector<vector<int> > b = binPow(a, n / 2);
		return multiply(b, b);
	}
}

//******************************************
//Kruskal Algorithm
struct edge {
    int from, to, cost;
    edge() {}
    edge(int from, int to, int cost): from(from), to(to), cost(cost) {};

    bool operator<(const edge& e) const {
		return cost < e.cost;
    }
};
//Sendo 'M' o numero de arestas, 'u' uma implementação do conjunto disjunto 'UnionFind' e 'ans' o menor custo
vector<edge> edges; //Populado com as arestas
int ans = 0;
for(i = 0; i < m; i++) {
	if(!u.find(edges[i].from, edges[i].to)) {
		u.unite(edges[i].from, edges[i].to);
		ans += edges[i].cost;
	}
}

//******************************************
//Prim Algorithm
int g[MAXN][MAXN], used[MAXN], min_e[MAXN], sel_e[MAXN];
min_e[0] = 0;
for (int i = 0; i < n; ++i) {
	int v = -1;
	for(int j = 0; j < n; ++j) {
		if (!used[j] && (v == -1 || min_e[j] < min_e[v])) {
			v = j;
		}
	}
	used[v] = true;
	if (sel_e[v] != -1) {
		ans += min_e[v];
	}
	for (int to = 0; to < n; ++to) {
		if (g[v][to] < min_e[to]) {
			min_e[to] = g[v][to];
			sel_e[to] = v;
		}
	}
}
//*********************************************
//LCA O(<Nlog(N)>, <log(N)>)
int N, Q, A, B;
vector<pair<int, int> > adj[MAXN];
int parent[MAXN], L[MAXN], vis[MAXN];
vector<int> level[MAXN];
int P[MAXN][20];
Int dist[MAXN];

void dfs(int pos, int par){
    if(parent[pos] == -1){
        parent[pos] = par;
		
        for(int i = adj[pos].size() - 1,to;i >= 0;--i){
            to = adj[pos][i].first;
            if(to != par) {
                dist[to] = dist[pos] + adj[pos][i].second;
                dfs(to,pos);
            }
        }
    }
}

int get_level(int u){
    if(L[u]!=-1) return L[u];
    else if(parent[u]==-1) return 0;
    return 1+get_level(parent[u]);
}

void init() {
	for(int i = 0;i<N;++i) {
		L[i] = get_level(i);
	}

	for(int i = 0;i < N;++i) {
		level[L[i]].push_back(i);
	}

	memset(P,-1,sizeof(P));
	
	for(int i = 0; i < N; ++i) {
		P[i][0] = parent[i];
	}
	
	for(int j = 1; (1<<j) < N; ++j) {
		for(int i = 0; i < N; ++i) {
			if(P[i][j-1]!=-1) {
				P[i][j] = P[P[i][j-1]][j-1];
			}
		}
	}
}

int LCA(int p, int q) {
    if(L[p] < L[q]) {
		swap(p,q);
	}

    int log = 1;
    while((1<<log)<=L[p]) ++log;
    --log;

    for(int i = log;i>=0;--i)
        if(L[p]-(1<<i)>=L[q])
            p = P[p][i];

    if (p==q) return p;

    for(int i = log;i>=0;--i){
        if(P[p][i]!=-1 && P[p][i]!=P[q][i]){
            p = P[p][i];
            q = P[q][i];
        }
    }

    return parent[p];
}

for (i = 0; i <= N; i++) {
	vis[i] = 0;
	L[i] = parent[i] = -1;
	dist[i] = 0LL;
	adj[i].clear();
 }
for (i = 1; i < N; i++) {
	scanf("%d%d", &t, &l);
	adj[i].push_back(make_pair(t, l));
	adj[t].push_back(make_pair(i, l));
 }

dfs(0, -2);
parent[0] = -1;
init();
//*********************************************
//LCA using segment tree
int H[MAXN], L[MAXN << 1], E[MAXN << 1], vis[MAXN], tree[MAXN * 8], path[MAXN << 1];
vector<vector<pair<int, int> > > g(MAXN);

void dfs(int x, int depth){
	vis[x] = 1;//visited
	if(H[x] == -1) H[x] = idx;//mark first time the i'th node is visited
	L[idx] = depth;//when you visit a node you should mark the the depth you have found it.
	E[idx++] = x;//the i'th recursion, global variable
	for(int i = 0; i < g[x].size(); i++){
		int next = g[x][i].first;
		if(!vis[next]){
			path[next] = x;
			dfs(next, depth+1);
			L[idx] = depth;
			E[idx++] = x;
		}
	}
}

//NlogN build the segtree and minimize the height of the I'th visited node
void build(int node, int l, int r){
	if(l > r) return;
	if(l == r){
		tree[node] = l;
	}else{
		int mid = (l+r) >> 1;
		build(node*2, l, mid);
		build(node*2+1, mid+1, r);
		int A = tree[node*2];
		int B = tree[node*2+1];
		if(L[A] <= L[B]){
			tree[node] = A;
		}else{
			tree[node] = B;
		}
	}
}

//Get the vertex with the minimum height, then it will be the LCA of A and B.
int rmq(int node, int l, int r, int ra, int rb){
	if(l > rb || r < ra){
		return -1;
	}else if(l >= ra && r <= rb){
		return tree[node];
	}else{
		int mid = (l+r) >> 1;
		int q1 = rmq(node*2, l, mid, ra, rb);
		int q2 = rmq(node*2+1, mid+1, r, ra, rb);
		if(q1 == -1){
			return q2;
		}else if(q2 == -1){
			return q1;
		}else{
			if(L[q1] <= L[q2]){
				return q1;
			}else{
				return q2;
			}
		}
	}
}

idx = 0;
for(int i = 0; i <= n; i++){
	g[i].clear();
	H[i] = -1;
	L[i] = E[i] = vis[i] = 0;
	path[i] = -1;
 }
dfs(0,0);
build(1, 0, 2*n-1);
for(int i = 0; i < k; i++){
	scanf("%d%d", &u, &v);
	u--;
	v--;
	int goFrom = H[u];
	int goTo = H[v];
	if(goFrom > goTo){
		swap(goFrom, goTo);
	}
	int lcaAB = E[rmq(1, 0, 2*n-1, goFrom, goTo)]; //is the LCA of A and B;
 }

//*********************************************
//2-sat (temp implementation)
map<string, int> mp;
string c1, c2;
int vis[MAXN], low[MAXN], num[MAXN], sat[MAXN],dfs_counter, scc_counter ,n, test = 1;
vector<vector<int> > graph(MAXN);
stack<int> st;

//Find strongly connected components
void tarjan(int u, int depth) {
	low[u] = num[u] = depth;
	st.push(u);
	vis[u] = 1;
	for(int i = 0; i < graph[u].size(); i++) {
		int v = graph[u][i];
		if(num[v] == -1){
			tarjan(v, depth+1);
		}
		if (vis[v]){
			low[u] = min(low[u], low[v]);
		}
	}
	if(low[u] == depth) {
		while(1) {
			int next = st.top();st.pop();
			sat[next] = scc_counter;
			vis[next] = 0;
			if(u == next) break;
		}
		++scc_counter;
	}
}

/*
  To use the 2-SAT property, it could be transformed in a boolean logic with AND or OR
  A | B, means !A -> B
  !A | B, means !!A -> B equals to A -> B
  A | !B means !A -> !B
  !A | !B means !!A -> !B equals to A -> !B
  
  "-> is an implicance to separate the usege of A AND B"
  
  2-sat property is YES if all the components have no disturbs, e.g.:
  If you find !A and A in the same "scc", you're talking that !A = true AND A = true, it is not right.
*/
int main(void){
	ios::sync_with_stdio(0);
	while(cin >> n){
		mp.clear();
		for(int i = 0; i < MAXN; i++){
			graph[i].clear();
			vis[i] = 0;
			num[i] = -1;
			sat[i] = -1;
			low[i] = 0;
		}
		cin.ignore();
		int index = 0;
		//Graph mount:
		for(int i = 0; i < n; i++){
			cin >> c1 >> c2;
			string tmpA, tmpB;
			bool A = 1, B = 1;
			if(c1[0] == '!'){
				tmpA = c1.substr(1);
				A = 0;
			}else{
				tmpA = c1;
			}
			if(c2[0] == '!'){
				tmpB = c2.substr(1);
				B = 0;
			}else{
				tmpB = c2;
			}
			if(mp.find(tmpA) == mp.end()){
				mp[tmpA] = index;
				index += 2;
			}
			if(mp.find(tmpB) == mp.end()){
				mp[tmpB] = index;
				index += 2;
			}
			int U = mp[tmpA] + !A, V = mp[tmpB] + !B;
			graph[U^1].push_back(V);
			graph[V^1].push_back(U);
		}
		dfs_counter = scc_counter = 0;
		for(int i = 0; i < index; i++){
			if(num[i] == -1){
				tarjan(i, 0);
			}
		}
		int win = 1;
		//Checking disturbs
		for(int i = 0; i < index && win; i += 2){
			if(sat[i^1] == sat[i]) win = 0;
		}
		printf("Instancia %d\n", test++);
		if(win){
			printf("sim\n");
		}else{
			printf("nao\n");
		}
		printf("\n");
	}
	return 0;
}
//*********************************************
//Dijkstra
struct MyLess {
    bool operator()(int x, int y) {
        return dist[x] > dist[y];
    }
};

int dijsktra(int source, int destiny) {
	for(int i = 0; i <= 110; i++) {
		dist[i] = INT_MAX;
	}
	priority_queue<int, vector<int>, MyLess> q;
	dist[source] = 0;
 	q.push(source);

	while(!q.empty()) {
		int tmp = q.top(); q.pop();
		for(int i = 0; i < graph[tmp].size(); i++) {
            int aux_dist = dist[tmp] + graph[tmp][i].second;
            int actual_dist = dist[graph[tmp][i].first];
            if(aux_dist < actual_dist) {
                dist[graph[tmp][i].first] = aux_dist;
                q.push(graph[tmp][i].first);
            }
        }
    }
	return dist[destiny];
}
//Reconstrução do Caminho
vector<int> path;
int start = destiny;

while(start != -1) {
	path.push_back(start);
	start = prev[start];
}
//*******************************************************
//Contando Pontes em um Grafo não Direcionado
int a, b, n, m, cont, ct, vis[1010], nivel[1010], menor[1010], pai[1010];
vector<int> graph[1010];
void dfs(int x) {
	vis[x] = 1;
	nivel[x] = menor[x] = cont++;
	int sons = 0;
	for(int i = 0; i < graph[x].size(); i++) {
		if(vis[graph[x][i]] == 0) {
		sons += 1;
		pai[graph[x][i]] = x;
		dfs(graph[x][i]);
		if(menor[graph[x][i]] < menor[x]) menor[x] = menor[graph[x][i]];
			if(menor[graph[x][i]] == nivel[graph[x][i]]) {
				ct++;
			}
		} else if(vis[graph[x][i]] == 1 && pai[x] != graph[x][i]) {
			if(nivel[graph[x][i]] < menor[x]) menor[x] = nivel[graph[x][i]];
		}
	}
	vis[x] = 2;
}
ct = numero final de pontes
//*******************************************************
//Achando Vertices de Articulação um Grafo
vector<int> graph[410];
set<int> ans;
set<int>::iterator it;

int dfs(int u){
    int less = vis[u] = times++;
    int filhos = 0;
    for(int i = 0; i< graph[u].size(); i++){
       if(vis[graph[u][i]]==0){
          filhos++;
          int m = dfs(graph[u][i]);
          less = min(less,m);
          if(vis[u] <= m && (u != 0 || filhos >= 2)){
              ans.insert(u);
          }
       }else{
          less = min(less, vis[graph[u][i]]);
       }
    }
    return less;
}
times = 1;
ans.clear();
dfs(0);
//*******************************************************
//Fluxo-Máximo - Edmonds-Karp O(N*M^2)
int max_flow(int source, int sink) {
    int residual[MAXN][MAXN]; memset(residual, 0, sizeof(residual));
    while(1) {
        int prev[MAXN]; memset(prev, -1, sizeof(prev));
        int actual[MAXN]; memset(actual, 0, sizeof(actual));
        prev[source] = source;
        actual[source] = INF;
        queue<int> q; q.push(source);
        while(!q.empty()) {
            int u = q.front(); q.pop();
            for(int i = 0; i < graph[u].size(); i++) {
                int v = graph[u][i];
                if(capacity[u][v] - residual[u][v] > 0 && prev[v] == -1) {
                    prev[v] = u;
                    actual[v] = min(actual[u], capacity[u][v] - residual[u][v]);
                    if(v != sink) {
                        q.push(v);
                    } else {
                        while(prev[v] != v) {
                            u = prev[v];
                            residual[u][v] += actual[sink];
                            residual[v][u] -= actual[sink];
                            v = u;
                        }
                        goto end;
                    }
                }
            }
        }
        end:;
        if(prev[sink] == -1) {
            int sum = 0;
            for(int i = 0; i < MAXN; i++) {
                sum += residual[source][i];
            }
            return sum;
        }
    }
}
memset(capacity, 0, sizeof(capacity));
int n, m, a, b, c;
scanf("%d%d", &n, &m); //Tamanho/Numero de Arestar
for(int i = 0; i < m; i++) {
	scanf("%d%d%d", &a, &b, &c); //DE-PARA-CUSTO
	graph[a].push_back(b); capacity[a][b] += c;
	graph[b].push_back(a); capacity[b][a] += c;
}
//*******************************************************
//Max Flow dinic O(V^2*E)
const int MAXN = 101010;
const int INF = 101011;

struct edge {
    int to,rev;
    Int cap;
    edge(int to, Int cap, int rev): to(to), cap(cap), rev(rev) {}
};

vector<edge> G[MAXN];
Int level[MAXN];
int iter[MAXN];

void init(int N) {
    for (int i = 0; i < N; i++) {
        G[i].clear();
    }
}

void add_edge(int from,int to,Int cap) {
    G[from].push_back(edge(to, cap, G[to].size()));
    G[to].push_back(edge(from, 0, G[from].size()-1));
}

void bfs(int s) {
    memset(level, -1, sizeof(level));
    queue<int> que;
    level[s] = 0;
    que.push(s);

    while(!que.empty()) {
        int v = que.front();
        que.pop();
        for (int i = 0; i < G[v].size(); i++) {
            edge& e = G[v][i];
            if(e.cap > 0 && level[e.to] < 0) {
                level[e.to] = level[v] + 1;
                que.push(e.to);
            }
        }
    }
}

Int dfs(int v, int t, Int f) {
    if(v == t) return f;
    for(int& i = iter[v]; i < (int) G[v].size(); i++) {
        edge &e = G[v][i];
        if(e.cap > 0 && level[v] < level[e.to]) {
            Int d = dfs(e.to, t, min(f, e.cap));
            if (d > 0) {
                e.cap -= d;
                G[e.to][e.rev].cap += d;
                return d;
            }
        }
    }
    return 0;
}

int max_flow(int s, int t) {
    Int flow = 0;
    for( ; ; ) {
        bfs(s);
        if (level[t] < 0) {
            return flow;
        }
        memset(iter, 0, sizeof(iter));
        int f;
        while ((f=dfs(s,t,INF*INF)) > 0) {
            flow += f;
        }
    }
}
//********************************************
// Minimum Cost Max Flow (good implementation)
struct edge {
    int to;
    int cap;
    int cost;
    int rev;
};

int V;
vector <edge> g[50];
int h[50];
int dist[50];
int prevv[50];
int preve[50];

void add_edge(int from, int to, int cap, int cost) {
    g[from].push_back((edge){to, cap, cost, g[to].size()});
    g[to].push_back((edge){from, 0, -cost, g[from].size() - 1});
}

long long min_cost_flow(int s, int t, int f) {
    long long res = 0, i;

    for (i = 0; i < V; i++) h[i] = 0;

    while (f > 0) {
        int d = f;
        priority_queue <pair<int, int> > q;

        for (i = 0; i < V; i++) dist[i] = 1e9;

        dist[s] = 0;

        q.push(make_pair(0, s));

        while (!q.empty()) {
            int c = -q.top().first;
            int v = q.top().second;

            q.pop();

            if (dist[v] < c) continue;

            for (i = 0; i < g[v].size(); i++) {
                edge &e = g[v][i];

                if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {
                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];
                    prevv[e.to] = v;
                    preve[e.to] = i;
                    q.push(make_pair(-dist[e.to], e.to));
                }
            }
        }

        if (dist[t] == 1e9) return 1e9;

        for (i = 0; i < V; i++) h[i] += dist[i];

        for (i = t; i != s; i = prevv[i]) d = min(d, g[prevv[i]][preve[i]].cap);

        f -= d;

        res += d * h[t];

        for (i = t; i != s; i = prevv[i]) {
            edge &e = g[prevv[i]][preve[i]];
            e.cap -= d;
            g[i][e.rev].cap += d;
        }
    }

    return res;
}


//Min Cost Max Flow (Alternative Implementation)
typedef int Flow;
typedef int Cost;
const Flow INF = 0x3f3f3f3f;
struct Edge {
    int src, dst;
    Cost cst;
    Flow cap;
    int rev;
};
bool operator<(const Edge a, const Edge b) {
    return a.cst>b.cst;
}

typedef vector<Edge> Edges;
typedef vector<Edges> Graph;

void add_edge(Graph&G, int u, int v, Flow c, Cost l) {
    G[u].push_back((Edge){ u, v, l, c, int(G[v].size()) });
    G[v].push_back((Edge){ v, u, -l, 0, int(G[u].size()-1) });
}

pair<Flow, Cost> flow(Graph&G, int s, int t, int K) {
    int n=G.size();
    Flow flow=0;
    Cost cost=0;
    for (;;) {
        priority_queue<Edge> Q;
        vector<int> prev(n, -1), prev_num(n, -1);
        vector<Cost> length(n, INF);
        Q.push((Edge){-1,s,0,0,0});
        prev[s]=s;
        for (;!Q.empty();) {
            Edge e=Q.top(); Q.pop();
            int v=e.dst;
            for (int i=0; i<(int)G[v].size(); i++) {
                if (G[v][i].cap>0 && length[G[v][i].dst]>e.cst+G[v][i].cst) {
                    prev[G[v][i].dst]=v;
                    Q.push((Edge){v, G[v][i].dst, e.cst+G[v][i].cst,0,0});
                    prev_num[G[v][i].dst]=i;
                    length[G[v][i].dst]=e.cst+G[v][i].cst;
                }
            }
        }
        if (prev[t]<0) return make_pair(flow, cost);

        Flow mi=INF;
        Cost cst=0;
        for (int v=t; v!=s; v=prev[v]) {
            mi=min(mi, G[prev[v]][prev_num[v]].cap);
            cst+=G[prev[v]][prev_num[v]].cst;
        }

	if (cst>K) return make_pair(flow, cost);

	if (cst != 0) mi = min(mi, K/cst);
	K -= cst*mi;
        cost+=cst*mi;

        for (int v=t; v!=s; v=prev[v]) {
            Edge &e=G[prev[v]][prev_num[v]];
            e.cap-=mi;
            G[e.dst][e.rev].cap+=mi;
        }
        flow += mi;
    }

}
//*******************************************************
//Maximum Bipartite Matching
int n, k;
vector<vector<int> > g;
vector<int> mt;
vector<char> used;

bool try_kuhn(int v) {
	if (used[v])  return false;
	used[v] = true;
	for (size_t i=0; i<g[v].size(); ++i) {
		int to = g[v][i];
		if (mt[to] == -1 || try_kuhn(mt[to])) {
			mt[to] = v;
			return true;
		}
	}
	return false;
}
mt.assign (k, -1);
for (int v=0; v<n; ++v) {
	used.assign (n, false);
	try_kuhn (v);
}

for (int i=0; i<k; ++i) {
	//Print partitions
	if (mt[i] != -1) {
		printf ("%d %d\n", mt[i]+1, i+1);
	}
 }

//*******************************************
//Floyd-Warshall - O(n^3)
for(int k = 0; k < n; k++) {
	for(int i = 0; i < n; i++) {
		for(int j = 0; j < n; j++) {
			dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
		}
	}
}
//*******************************************
//Global Min-Cut Stoer-Wager O(N^3)
int graph[MAXN][MAXN] //Matrix de Adjacencia do grafo.

int minCut(int n) {
    bool a[n];
    int v[n];
    int w[n];
    for(int i = 0; i < n; i++) v[i] = i;
    int best = INF;
    while(n > 1) {
        int maxj = 1;
        a[v[0]] = true;
        for(int i = 1; i < n; ++i) {
            a[v[i]] = false;
            w[i] = graph[v[0]][v[i]];
            if(w[i] > w[maxj]) {
                maxj = i;
            }
        }
        int prev= 0 ,buf = n;
        while(--buf) {
            a[v[maxj]]=true;
            if(buf == 1) {
                best = min(best, w[maxj]);
                for(int k = 0; k < n; k++) {
                    graph[v[k]][v[prev]]= (graph[v[prev]][v[k]] += graph[v[maxj]][v[k]]);
                }
                v[maxj] = v[--n];
            }
            prev = maxj;
            maxj = -1;
            for(int j = 1; j < n; ++j) {
                if(!a[v[j]]) {
                    w[j] += graph[v[prev]][v[j]];
                    if(maxj < 0 || w[j] > w[maxj]) {
                        maxj=j;
                    }
                }
            }
        }
    }
    return best;
}
//*****************************Geometria*************************************//
//Distance between point - line
double dot(pair<int, int> &A, pair<int, int> &B, pair<int, int> &C) {
    return (double) (B.first - A.first) * (C.first - B.first) + (B.second - A.second) * (C.second - B.second);
}

double cross(pair<int, int> &A, pair<int, int> &B, pair<int, int> &C) {
    return (double) (B.first-A.first) * (C.second-A.second) - (B.second-A.second) * (C.first-A.first);
}

double _distance(pair<int, int> A, pair<int, int> B) {
    int d1 = A.first - B.first;
    int d2 = A.second - B.second;
    return sqrt(d1*d1+d2*d2);
}

double linePointDist(pair<int, int> A, pair<int, int> B, pair<int, int> C, bool isSegment) {
    double dist = cross(A,B,C) / _distance(A,B);
    if(isSegment) {
        int dot1 = dot(A,B,C);
        if(dot1 > 0)return _distance(B,C);
        int dot2 = dot(B,A,C);
        if(dot2 > 0)return _distance(A,C);
    }
    return abs(dist);
}
//*********************************
Cordenadas integrais em um segmento, incluindo os pontos iniciais e finais:
Segmento entre pontos (x1, y1) e (x2, y2) = gcd(abs(x1 - x2), abs(y1 - y2)) + 1

//*****************************
//Area de um Poligono Convexo
double area() {
	int N = 4;
	int[] x = { 2, -4, 5, 2 };
	int[] y = { 5, 3, 1, 5 };

	double ma = x[N - 1] * y[0], mb = x[0] * y[N - 1];

	for (int i = 0; i < N - 1; i++) {
		ma += (x[i] * y[i + 1]);
		mb += (x[i + 1] * y[i]);
	}

	double ans = Math.abs((ma - mb) * 0.5);
}
//*********************************
//Distancia em linha reta (straight line)
double euclideanDistance(int x1, x2, int y1, int y2){
	return sqrt(pow(x2 - x1, 2) + pow(y2 - y1, 2));
}
//***********************************
// distancia
double manhatanDistance(int x1, int x2, int y1, int y2){
	return abs(x1 - x2) + abs(y2 - y1);
}
//************************************
//area do circulo
double circleArea(double r){
	return (r * r) * acos(-1);
}
//**************************************
//raio do circulo
double raio(int circunferencia){
	return circunferencia / acos(-1) / 2;
}
//***************************************
//Convex Hull
struct point {
    int x, y;
    point(int x, int y): x(x), y(y){}
    point(){}
    bool operator <(const point &p) const {
        return x < p.x || (x == p.x && y < p.y);
    }
    bool operator==(const point &p) const {
        return x == p.x && y == p.y;
    }
};
ll cross(const point &O, const point &A, const point &B) {
    return (A.x - O.x) * (B.y - O.y) - (A.y - O.y) * (B.x - O.x);
}

vector<point> convex_hull(vector<point> &P) {
    int n = P.size(), k = 0;
    vector<point> H(2*n);

    sort(P.begin(), P.end());

    for (int i = 0; i < n; i++) {
        while (k >= 2 && cross(H[k-2], H[k-1], P[i]) <= /*change to < to remove equal points */ 0) k--;
        H[k++] = P[i];
    }
    for (int i = n-2, t = k+1; i >= 0; i--) {
        while (k >= t && cross(H[k-2], H[k-1], P[i]) <= /*change to < to remove equal points */ 0) k--;
        H[k++] = P[i];
    }
    H.resize(k);
    return H;
}
//***************************************
//Point structure
//Piece of code stracted from the hichhikin guide to programming
//start from any initial values.

const double PI = 2.0*acos(0.0);
const double EPS = 1e-9; //too small/big?????
struct PT {
	double x,y;
	double length() {
		return sqrt(x*x+y*y);
	}
	int normalize() {
		double l = length();
		if(fabs(l)<EPS) return -1;
		x/=l; y/=l;
		return 0;
	}
	PT operator-(PT a) {
		PT r;
		r.x=x-a.x; r.y=y-a.y;
		return r;
	}
	PT operator+(PT a){
		PT r;
		r.x=x+a.x; r.y=y+a.y;
		return r;
	}
	PT operator*(double sc) {
		PT r;
		r.x=x*sc; r.y=y*sc;
		return r;
	}
};
bool operator<(const PT& a,const PT& b) {
	if(fabs(a.x-b.x)<EPS) return a.y<b.y;
	return a.x<b.x;
}
double dist(PT& a, PT& b){
	return sqrt((a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y));
}
double dot(PT& a, PT& b) {
	return(a.x*b.x+a.y*b.y);
}
r.x=x*sc; r.y=y*sc;
// ===============================================================
// Areas
// ===============================================================
double trap(PT a, PT b) {
	return (0.5*(b.x - a.x)*(b.y + a.y));
}
double area(vector<PT> &vin) {
	// Area of a simple polygon, not neccessary convex
	int n = vin.size();
	double ret = 0.0;
	for(int i = 0; i < n; i++) {
		ret += trap(vin[i], vin[(i+1)%n]);
	}
	return fabs(ret);
}
double peri(vector<PT> &vin) {
	// Perimeter of a simple polygon, not neccessary convex
	int n = vin.size();
	double ret = 0.0;
	for(int i = 0; i < n; i++) {
		ret += dist(vin[i], vin[(i+1)%n]);
	}
	return ret;
}
double triarea(PT a, PT b, PT c) {
	//Triangle area
	return fabs(trap(a,b)+trap(b,c)+trap(c,a));
}
double height(PT a, PT b, PT c) {
	// height from a to the line bc
	double s3 = dist(c, b);
	double ar = triarea(a,b,c);
	return (2.0*ar/s3);
}
//***************************************
//Check wheter a polygon is convex
int sideSign(PT& p1,PT& p2,PT& p3) {
	// which side is p3 to the line p1->p2? returns: 1 left, 0 on, -1 right
	double sg = (p1.x-p3.x)*(p2.y-p3.y)-(p1.y - p3.y)*(p2.x-p3.x);
	if (fabs(sg)<EPS) return 0;
	if (sg>0) return 1;
	return -1;
}
int isConvex(vector<PT>& v) {
	// test whether a simple polygon is convex
	// return 0 if not convex, 1 if strictly convex,
	// 2 if convex but there are points unnecesary
	// this function does not work if the polycon is self intersecting
	// in that case, compute the convex hull of v, and see if both have the same area
	int i,j,k;
	int c1=0; int c2=0; int c0=0;
	int n=v.size();
	for(i = 0;i < n; i++) {
		j= (i+1)%n;
		k= (j+1)%n;
		int s = sideSign(v[i], v[j], v[k]);
		if (s == 0) c0++;
		if (s > 0) c1++;
		if (s < 0) c2++;
	}
	if(c1 && c2) return 0;
	if(c0) return 2;
	return 1;
}
// ====================================================
// Points and Lines
// ====================================================
int intersection( PT p1, PT p2, PT p3, PT p4, PT &r) {
	// two lines given by p1->p2, p3->p4 r is the intersection point
	// return -1 if two lines are parallel
	double d = (p4.y - p3.y)*(p2.x-p1.x) - (p4.x - p3.x)*(p2.y - p1.y);
	if( fabs( d ) < EPS ) return -1;
	// might need to do something special!!!
	double ua, ub;
	ua = (p4.x - p3.x)*(p1.y-p3.y) - (p4.y-p3.y)*(p1.x-p3.x);
	ua /= d;
	// ub = (p2.x - p1.x)*(p1.y-p3.y) - (p2.y-p1.y)*(p1.x-p3.x);
	//ub /= d;
	r = p1 + (p2-p1)*ua;
	return 0;
}

void closestpt( PT p1, PT p2, PT p3, PT &r) {
	// the closest point on the line p1->p2 to p3
	if (fabs( triarea( p1, p2, p3)) < EPS) {
		r = p3;
		return;
	}
	PT v = p2-p1;
	v.normalize();
	double pr; // inner product
	pr = (p3.y-p1.y)*v.y + (p3.x-p1.x)*v.x;
	r = p1+v*pr;
}
int hcenter( PT p1, PT p2, PT p3, PT& r) {
	// point generated by altitudes
	if (triarea( p1, p2, p3 ) < EPS) return -1;
	PT a1, a2;
	closestpt( p2, p3, p1, a1 );
	closestpt( p1, p3, p2, a2 );
	intersection( p1, a1, p2, a2, r );
	return 0;
}
int center( PT p1, PT p2, PT p3, PT& r) {
	// point generated by circumscribed circle
	if (triarea( p1, p2, p3 ) < EPS) return -1;
	PT a1, a2, b1, b2;
	a1 = (p2+p3)*0.5;
	a2 = (p1+p3)*0.5;
	b1.x = a1.x - (p3.y-p2.y);
	b1.y = a1.y + (p3.x-p2.x);
	b2.x = a2.x - (p3.y-p1.y);
	b2.y = a2.y + (p3.x-p1.x);
	intersection(a1, b1, a2, b2, r);
	return 0;
}

//***************************************
//Biblioteca de fracoes
struct fraction {
    int num, denom;
    fraction(int num, int denom): num(num), denom(denom){
    }
    fraction() { num = 0; denom = 0; }
    void reduce(fraction& f) {
        int l = gcd(f.num, f.denom);
        f.num = f.num/l;
        f.denom = f.denom/l;
    }
    fraction operator+(const fraction& f) {
        fraction ans;
        int l = lcm(denom, f.denom);
        ans.num = ((l / denom) * num) + ((l / f.denom) * f.num);
        ans.denom = l;
        reduce(ans);
        return ans;
    }
    fraction operator-(const fraction& f) {
        fraction ans;
        ans.num = num - f.num;
        ans.denom = denom - f.denom;
        reduce(ans);
        return ans;
    }
    fraction operator*(const fraction& f) {
        fraction ans;
        ans.num = num * f.num;
        ans.denom = denom * f.denom;
        reduce(ans);
        return ans;
    }
    fraction operator/(const fraction& f) {
        fraction ans;
        ans.num = num * f.denom;
        ans.denom = denom * f.num;
        reduce(ans);
        return ans;
    }
    bool operator!=(const fraction& f) {
        return num != f.num || denom != f.denom;
    }
    bool operator==(const fraction& f) {
        return num == f.num && denom == f.denom;
    }
    friend ostream &operator<<(ostream &out, fraction f) {
        out << f.num << "/" << f.denom << "\n";
        return out;
    }
    friend istream &operator>>(istream &in, fraction f) {
        in >> f.num >> f.denom;
        return in;
    }
};


//***************************************
//Polygon Area
int area = 0;
int N = lengthof(p);
//We will triangulate the polygon
//into triangles with points p[0],p[i],p[i+1]

for(int i = 1; i+1<N; i++){
    int x1 = p[i][0] - p[0][0];
    int y1 = p[i][1] - p[0][1];
    int x2 = p[i+1][0] - p[0][0];
    int y2 = p[i+1][1] - p[0][1];
    int cross = x1*y2 - x2*y1;
    area += cross;
}
return abs(cross/2.0);
//*******************************************************
//Checando se 2 segmentos se cruzam
A = y2-y1
B = x1-x2
C = A*x1+B*y1
A1x + B1y = C1
A2x + B2y = C2
double det = A1*B2 - A2*B1
if(det == 0){
	//Lines are parallel
}else{
	double x = (B2*C1 - B1*C2)/det
   double y = (A1*C2 - A2*C1)/det
}
/* ************************************ Dynamic Programming ***************************** */
//*******************************************************
//Binomial Coefficient
//C(N, K) = N!/(K!(N - K)!)
int bin[N][K];
bin[0][0] = 1;
for(n = 1; n < MAXN; n++) {
    bin[n][0] = 1;
    bin[n][n] = 1;
    for (k = 1; k < n; k++) {
		bin [n][k] = bin [n - 1][k] + bin [n - 1][k - 1];
		if (bin[n][k] >= MOD) {
			bin[n][k] -= MOD;
		}
    }
 }
//*******************************************************
//String distance
int dist(string& s1, string& s2) {
    int N1 = s1.size(), N2 = s2.size();

    REP(i, N1+1) dp[i][0] = i;
    REP(i, N2+1) dp[0][i] = i;

    FOR(i, 1, N1+1) FOR(j, 1, N2+1) {
        if(s1[i-1] == s2[j-1]) {
            dp[i][j] = dp[i-1][j-1];
        } else {
            dp[i][j] = 1 + min(min(dp[i-1][j], dp[i][j-1]), dp[i-1][j-1]);
        }
    }
    return dp[N1][N2];
}
//*******************************************************
//Coin Change
int dp[1001];
int coins[] = {1, 5, 10, 25, 50};
dp[0] = 0;

for(int i = 1; i <= 74; i++) {
	int min = 1000001;
    for(int j = 0; j < 5; j++) {
		if(coins[j] <= i) {
			int m = dp[i - coins[j]] + 1;
            if(m < min) min = m;
        }
    }
    dp[i] = min;
}
//*******************************************************
//Counting ways to sum value 'x' using coins in set 'coins'
memo[0] = 1;
for(int i = 0; i < 5; i++) {
    int c = coins[i];
    for(int j = c; j <= x; j++) {
	memo[j] += memo[j - c];
    }
}
//*******************************************************
//Longest Increasing Subsequence - (LIS) O(Nlog(N))
void funcA(void) {
    int i, top = 0;

    stk[0] = INT_MIN;

    for (i = 0; i < N; ++i) {
        if (v[i] > stk[top]) {
            stk[++top] = v[i];
        } else {
            int low = 0, high = top;
            while (low <= high) {
                int mid = (low + high) >> 1;
                if (v[i] > stk[mid]) {
                    low = mid + 1;
                } else {
                    high = mid - 1;
                }
            }
            stk[low] = v[i];
        }
        in[i] = top;
    }
}
//*******************************************************
//Longest Increasing Subsequence - (LIS) O(N^2)
int lis(int array[], int n) {
    int best[n], prev[n];

    for(int i = 0; i < n; i++) {
        best[i] = 1;
        prev[i] = i;
    }

    for(int i = 1; i < n; i++) {
        for(int j = 0; j < i; j++) {
            if(array[i] > array[j] && best[i] < best[j] + 1) {
                best[i] = best[j] + 1; prev[i] = j;
            }
        }
    }
    int ans = 0; for(int i = 0; i < n; i++) ans = max(ans, best[i]);
    return ans;
}
//*******************************************************
//Longest Commom Subsequence - (LCS) O(N^2)
int lgs(string a, string b) {
	int n = a.size(), m = b.size();
	int[][] dp = new dp[n+1][m+1];

	for(int i = 0; i <= max(n, m); i++) {
		dp[i][0] = dp[0][i] = 0;
	}
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= m; j++) {
			if(a[i] == b[j]) {
				dp[i][j] = dp[i - 1][j - 1] + 1;
			} else {
				dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
			}
		}
	}
	return dp[n][m];
}
//*******************************************************
//Menor string que contem duas strings S1 e S2 como subsequencia

char S1[MAXS], S2[MAXS];
int dp[MAXS][MAXS];

memset(dp, 0, sizeof(dp));

for (i = 1; i <= N; i++) {
    for (j = 1; j <= M; j++) {
        if (S1[i - 1] == S2[j - 1]) {
            dp[i][j] = dp[i - 1][j - 1] + 1;
        } else {
           dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
        }
    }
}

string track(int i, int j) {
    if (i == 0 && j == 0) {
        return "";
    } else if (i == 0 && j > 0) {
        return track(i, j - 1) + S2[j - 1];
    } else if (i > 0 && j == 0) {
        return track(i - 1, j) + S1[i - 1];
    } else {
        if (S1[i - 1] == S2[j - 1]) {
            return track(i - 1, j - 1) + S1[i - 1];
        } else {
            if (dp[i][j - 1] > dp[i - 1][j]) {
                return track(i, j - 1) + S2[j - 1];
            } else {
                return track(i - 1, j) + S1[i - 1];
            }
        }
    }
}
//*******************************************************
//Subset-Sum -> (G = O valor total sendo testado, N = numero de valores disponiveis no array 'values'
int values[n];
bool subsetSum(int n, int g) {
    for(j = 0; j <= g; j++) sub[j] = 0;
    sub[0] = 1;
    for(j = 0; j < n; j++) if(values[j] != g) {
        for(int k = g; k >= values[j]; k--) {
            sub[k] |= sub[k - values[j]];
        }
    }
    return sub[g];
}
//*******************************************************
//Checa por Palindromos
int T, N, dp[MAXN][MAXN];
char str[MAXN];

REP(i, N) {
    dp[i][i] = 1;
    if(i + 1 < N) dp[i][i + 1] = str[i] == str[i + 1];
}
for(int k = 2; k < N; k++) {
    REP(i, N - k) {
        dp[i][i + k] = dp[i + 1][i + k - 1] && str[i] == str[i + k];
    }
}
//*******************************************************
//Domino perfect matching - recursive
int a, b, i, j, k, n, ok, teste = 1, mem[7][7];

void rec(int now, int deep) {
    if(deep == n) {
        ok = 1;
        return;
    }
    for(j = 0; j <= 6; j++) {
        int i = j;
        if(mem[now][i]>0) {
            mem[now][i]--;
            mem[i][now]--;
            rec(i, deep + 1);
            if(ok == 1) return;
            mem[now][i]++;
            mem[i][now]++;
        }
    }
}

int main(void) {
    while(scanf("%d", &n) && n != 0) {
        memset(mem, 0, sizeof(mem));
        ok = 0;
        for(i = 0; i < n; i++) {
            scanf("%d%d", &a, &b);
            mem[a][b] += 1;
            mem[b][a] += 1;
        }
        for(k = 0; k <= 6; k++) {
            rec(k, 0);
            if(ok == 1) break;
        }
	// ok == 1, matching perfeito
    }
}
//*******************************************************
//Domino perfect matching - graph
void dfs(int x) {
    vis[x] = 1;
    for(int j = 0; j <= 6; j++) {
        if(vis[j] == 0 && mem[x][j] == 1) dfs(j);
    }
}

int main(void) {
    while(scanf("%d", &n) && n != 0) {
        memset(mem, 0, sizeof(mem)); memset(vis, 0, sizeof(vis)); memset(ct, 0, sizeof(ct));
        for(int i = 0; i < n; i++) {
            scanf("%d%d", &a, &b);
            ct[a] += 1;
            ct[b] += 1;
            mem[a][b] = 1;
            mem[b][a] = 1;
        }
        for(int i = 0; i <= 6; i++) {
            if(ct[i] > 0) {
                dfs(i); break;
            }
        }
        ok = 1;
        for(int i = 0; i <= 6; i++) {
            if(ct[i] > 0 && !vis[i]) {
                ok = 0;
            }
        }
        int o = 0;
        for(int i = 0; i <= 6; i++) {
            if(ct[i] % 2 == 1) o++;
        }
        printf("Teste %d\n%s\n\n", teste++, ok == 1 && (o == 0 || o == 2) ? "sim" : "nao");
    }
}
/* *************************** Data Structures ***************************/
//******************************************************
//Splay Tree
template< typename T, typename Comp = std::less< T > >
class splay_tree {
private:
  Comp comp;
  unsigned long p_size;
 
  struct node {
    node *left, *right;
    node *parent;
    T key;
    node( const T& init = T( ) ) : left( 0 ), right( 0 ), parent( 0 ), key( init ) { }
  } *root;
 
  void left_rotate( node *x ) {
    node *y = x->right;
    x->right = y->left;
    if( y->left ) y->left->parent = x;
    y->parent = x->parent;
    if( !x->parent ) root = y;
    else if( x == x->parent->left ) x->parent->left = y;
    else x->parent->right = y;
    y->left = x;
    x->parent = y;
  }
 
  void right_rotate( node *x ) {
    node *y = x->left;
    x->left = y->right;
    if( y->right ) y->right->parent = x;
    y->parent = x->parent;
    if( !x->parent ) root = y;
    else if( x == x->parent->left ) x->parent->left = y;
    else x->parent->right = y;
    y->right = x;
    x->parent = y;
  }
 
  void splay( node *x ) {
    while( x->parent ) {
      if( !x->parent->parent ) {
        if( x->parent->left == x ) right_rotate( x->parent );
        else left_rotate( x->parent );
      } else if( x->parent->left == x && x->parent->parent->left == x->parent ) {
        right_rotate( x->parent->parent );
        right_rotate( x->parent );
      } else if( x->parent->right == x && x->parent->parent->right == x->parent ) {
        left_rotate( x->parent->parent );
        left_rotate( x->parent );
      } else if( x->parent->left == x && x->parent->parent->right == x->parent ) {
        right_rotate( x->parent );
        left_rotate( x->parent );
      } else {
        left_rotate( x->parent );
        right_rotate( x->parent );
      }
    }
  }
 
  void replace( node *u, node *v ) {
    if( !u->parent ) root = v;
    else if( u == u->parent->left ) u->parent->left = v;
    else u->parent->right = v;
    if( v ) v->parent = u->parent;
  }
 
  node* subtree_minimum( node *u ) {
    while( u->left ) u = u->left;
    return u;
  }
 
  node* subtree_maximum( node *u ) {
    while( u->right ) u = u->right;
    return u;
  }
public:
  splay_tree( ) : root( 0 ), p_size( 0 ) { }
 
  void insert( const T &key ) {
    node *z = root;
    node *p = 0;
 
    while( z ) {
      p = z;
      if( comp( z->key, key ) ) z = z->right;
      else z = z->left;
    }
 
    z = new node( key );
    z->parent = p;
 
    if( !p ) root = z;
    else if( comp( p->key, z->key ) ) p->right = z;
    else p->left = z;
 
    splay( z );
    p_size++;
  }
 
  node* find( const T &key ) {
    node *z = root;
    while( z ) {
      if( comp( z->key, key ) ) z = z->right;
      else if( comp( key, z->key ) ) z = z->left;
      else return z;
    }
    return 0;
  }
 
  void erase( const T &key ) {
    node *z = find( key );
    if( !z ) return;
 
    splay( z );
 
    if( !z->left ) replace( z, z->right );
    else if( !z->right ) replace( z, z->left );
    else {
      node *y = subtree_minimum( z->right );
      if( y->parent != z ) {
        replace( y, y->right );
        y->right = z->right;
        y->right->parent = y;
      }
      replace( z, y );
      y->left = z->left;
      y->left->parent = y;
    }
 
    delete z;
    p_size--;
  }
 
  const T& minimum( ) { return subtree_minimum( root )->key; }
  const T& maximum( ) { return subtree_maximum( root )->key; }
 
  bool empty( ) const { return root == 0; }
  unsigned long size( ) const { return p_size; }
};
//*******************************************************
//Trie
struct Trie {
    Trie *child[MAXN];
    int prefixes;
    int words;

    Trie() {
        int i;
        prefixes = words = 0;
        for(i = 0; i < MAXN; i++) {
            child[i] = NULL;
        }
    }

    void addWord(string s, int pos = 0) {
        if(pos == s.size()) {
            words++;
            return;
        }

        int letter_pos = s[pos] - 'a';

        Trie *t = child[letter_pos];

        if(child[letter_pos] == NULL) {
            t = child[letter_pos] = new Trie();
            t->prefixes = 1;
        } else {
            t->prefixes = t->prefixes + 1;
        }
        t->addWord(s, pos + 1);
    }

    int count(string s, int pos = 0, int k = 0) {
        if(pos == s.size()) return k;
        Trie *t = child[s[pos] - 'a'];
        if(t == NULL) return 0;
        return t->count(s, pos + 1, (prefixes == t->prefixes) ? k: k + 1);
    }
};
//*******************************************************
//Union Find
struct UnionFind {
    int N, *id, *sz;

    UnionFind(int _N) {
        id = new int[_N];
        sz = new int[_N];
        for(int i = 0; i < _N; i++) {
            id[i] = i;
            sz[i] = 1;
        }
        N = _N;
    }
    int root(int i) {
        while(i != id[i]) {
            id[i] = id[id[i]];
            i = id[i];
        }
        return i;
    }
    bool find(int p, int q) {
        return root(p) == root(q);
    }
    void unite(int p, int q) {
        int i = root(p);
        int j = root(q);
        if(i == j) return;
        if(sz[i] < sz[j]) {
            id[i] = j; sz[j] += sz[i];
        } else {
            id[j] = i; sz[i] += sz[j];
        }
    }
};
//*******************************************************
//Binary Indexed Tree(Fenwick Tree)
template<typename T = int>
struct FenwickTree {
    int N;
    T *values;

    FenwickTree(int N) {
        this->N = N;
        values = new T[N+5];

        for(int i = 1; i <= N; i++) values[i] = 0;
    }

    void increase(int index, T add) {
        while(index <= N) {
            values[index] += add;
            index += (index & -index);
        }
    }

    void update(int index, T new_value) {
        increase(index, new_value - readSingle(index));
    }

    T read(int index) {
        T sum = 0;

        while(index > 0) {
            sum += values[index];
            index -= (index & -index);
        }

        return sum;
    }

    T readSingle(int index){
        T sum = values[index];
        if(index > 0) {
            int z = index - (index & -index);
            index--;
            while(index != z) {
                sum -= values[index];
                index -= (index & -index);
            }
        }
        return sum;
    }

    T read(int low, int high) {
        return read(high) - read(low - 1);
    }

    void scale(T factor) {
        for(int i = 1; i <= N; i++) {
            values[i] /= factor;
        }
    }

    void power(T factor) {
        for(int i = 1; i <= N; i++) {
            values[i] *= factor;
        }
    }
};
//*******************************************************
//Binary Indexed Tree 2D(Fenwick Tree 2D)
const int INF = 1000 * 1000 * 1000;

int n, m;
vector <vector <int>> t;

void init(int _n, int _m) {
    n = _n;
    m = _m;
    for(int i = 0; i < n; i++) {
        t.push_back(vector<int>(m, 0));
    }
}

int sum(int x, int y) {
    int result = 0;
    for (int i = x; i> = 0; i = (i & (i +1)) - 1) {
        for (int j = y; j> = 0; j = (j & (j +1)) - 1) {
            result += t[i][j];
        }
    }
    return result;
}

void inc (int x, int y, int delta) {
    for (int i = x; i <n; i = (i | (i +1))) {
        for (int j = y; j <m; j = (j | (j +1))) {
            t[i][j] += delta;
        }
    }
}

void update(int x, int y, int new_value) {
    for (int i = x; i> = 0; i = (i & (i +1)) - 1) {
        for (int j = y; j> = 0; j = (j & (j +1)) - 1) {
            t[i][j] = new_value;
        }
    }
}

int sum(int x1, int y1, int x2, int y2) {
    return sum(std::max(x1, x2), std::max(y1, y2)) - sum(std::min(x1, x2)-1, std::min(y1, y2)-1);
}
//*******************************************************
//Simple Segment Tree
const int MAXN = 4;
const int INF = 10000010;

int a[10];

template<typename T>
struct SegmentTree {
    int N;
    T tree[3*MAXN];

    SegmentTree(int _N) {
        N = _N;
        for(int i = 0; i < 3*MAXN; i++) tree[i] = 0;
    }

    void build(T a[], int v, int tl, int tr) {
        if (tl == tr) {
            tree[v] = a[tl];
        } else {
            int mid = (tl + tr) / 2;
            build(a, v*2, tl, mid);
            build(a, v*2+1, mid+1, tr);
            tree[v] = tree[v*2] + tree[v*2+1];
        }
    }

    void build(T a[]) {
        build(a, 1, 0, N);
    }

    T sum(int v, int tl, int tr, int l, int r) {
        if (l > r) {
            return 0;
        }
        if(l == tl && r == tr) {
            return tree[v];
        }
        int mid = (tl + tr) / 2;
        return sum(v*2, tl, mid, l, min(r,mid)) + sum(v*2+1, mid+1, tr, max(l,mid+1), r);
    }

    T sum(int l, int r) {
        return sum(1, 0, N, l, r);
    }

    //Only works if you change the routine of build and update the tree
    T prod(int v, int tl, int tr, int l, int r) {
        if(l > r) {
            return 1;
        }
        if(l == tl && r == tr) {
            return tree[v];
        }
        int mid = (tl + tr) / 2;
        return prod(v*2, tl, mid, l, min(r,mid)) * prod(v*2+1, mid+1, tr, max(l,mid+1), r);
    }

    T prod(int l, int r) {
        return prod(1, 0, N, l, r);
    }

    void update_change(int v, int tl, int tr, int pos, T new_val) {
        if (tl == tr) {
            tree[v] = new_val;
        } else {
            int mid = (tl + tr) >> 1;
            if(pos <= mid) {
                update_change(v*2, tl, mid, pos, new_val);
            } else {
                update_change(v*2+1, mid+1, tr, pos, new_val);
            }
            tree[v] = tree[v*2] + tree[v*2+1];
        }
    }

    void update_change(int pos, T new_val) {
        update_change(1, 0, N, pos, new_val);
    }

    void update_add_single(int v, int tl, int tr, int pos, T add) {
        if (tl == tr) {
            tree[v] += add;
        } else {
            int mid = (tl + tr) >> 1;
            if(pos <= mid) {
                update_add_single(v*2, tl, mid, pos, add);
            } else {
                update_add_single(v*2+1, mid+1, tr, pos, add);
            }
            tree[v] = tree[v*2] + tree[v*2+1];
        }
    }

    void update_add_single(int pos, T add) {
        update_add_single(1, 0, N, pos, add);
    }

    void update_add_range_helper(int v, int tl, int tr, int l, int r, T add) {
        if(l > r) {
            return;
        }
        if(l == tl && tr == r) {
            tree[v] += add;
        } else {
            int mid = (tl + tr) >> 1;
            update_add_range_helper(v*2, tl, mid, l, min(r,mid), add);
            update_add_range_helper(v*2+1, mid+1, tr, max(l,mid+1), r, add);
            tree[v] = tree[v*2] + tree[v*2 + 1];
        }
    }

    void update_add_range(int v, int tl, int tr, int l, int r, int add) {
        if(tl == l && tr == r) {
            update_add_range_helper(v, tl, tr, l + 1, r - 1, add);
            update_add_single(v, tl, tr, l, add);
        } else {
            update_add_range_helper(v, tl, tr, l, r, add);
        }
    }

    void update_add_range(int l, int r, T add) {
        update_add_range(1, 0, N, l, r, add);
    }

};//*******************************************************
//Segment Tree which find max and min value of an interval [l, r)
#define MAXN 1000
#define INF 10000000


int a[4*MAXN];
pair<int,int> t[4*MAXN];

pair<int,int> combine (pair<int,int> a, pair<int,int> b) {
	if (a.first > b.first)
		return a;
	if (b.first > a.first)
		return b;
	return make_pair (a.first, a.second + b.second);
}

pair<int,int> combine2(pair<int,int> a, pair<int,int> b) {
	if (a.first < b.first)
		return a;
	if (b.first < a.first)
		return b;
	return make_pair(a.first, a.second + b.second);
}

void build (int a[], int v, int tl, int tr) {
	if (tl == tr)
		t[v] = make_pair (a[tl], 1);
	else {
		int tm = (tl + tr) / 2;
		build (a, v*2, tl, tm);
		build (a, v*2+1, tm+1, tr);
		t[v] = combine (t[v*2], t[v*2+1]);
	}
}

pair<int,int> get_max (int v, int tl, int tr, int l, int r) {
	if (l > r)
		return make_pair (-INF, 0);
	if (l == tl && r == tr)
		return t[v];
	int tm = (tl + tr) / 2;
	return combine (
		get_max (v*2, tl, tm, l, min(r,tm)),
		get_max (v*2+1, tm+1, tr, max(l,tm+1), r)
	);
}

void update (int v, int tl, int tr, int pos, int new_val) {
	if (tl == tr)
		t[v] = make_pair (new_val, 1);
	else {
		int tm = (tl + tr) / 2;
		if (pos <= tm)
			update (v*2, tl, tm, pos, new_val);
		else
			update (v*2+1, tm+1, tr, pos, new_val);
		t[v] = combine (t[v*2], t[v*2+1]);
	}
}

//*******************************************************
//RMQ - Segment Tree
const int MAXN = 20000;
const int INF = 10000000;

//0-Based Range Minimum Query Segment Tree
template<typename T>
struct SegmentTreeRMQ {
    pair<T, T> t[MAXN*4];
    void build(T a[], int v, int tl, int tr) {
        if (tl == tr) t[v].first = a[tl];
        else {
            int tm = (tl + tr) >> 1;
            build (a, 2*v,tl,tm);
            build (a, 2*v+1,tm+1,tr);
            t[v].first = min (t[2*v].first,t[2*v+1].first);
        }
    }

    void update(int v, int tl, int tr, int l, int r, T value) {
        if (l > r) return;
        if (tl == l && r == tr) {
            t[v].second += value;
        } else {
            int tm = (tl + tr) >> 1;
            update (2*v,tl,tm,l,min(tm,r),value);
            update (2*v+1,tm+1,tr,max(tm+1,l),r,value);
            t[v].first = min (t[2*v].first + t[2*v].second,t[2*v+1].first + t[2*v+1].second);
        }
    }
    T rmq (int v, int tl, int tr, int l, int r) {
        if (l > r) {
            return INF;
        }
        if (tl == l && tr == r) {
            return t[v].first + t[v].second;
        } else {
            int tm = (tl + tr) >> 1;
            t[v].first = min (t[2*v].first + t[2*v].second,t[2*v+1].first + t[2*v+1].second);
            return min(rmq(2*v,tl,tm,l,min(tm,r)),rmq(2*v+1,tm+1,tr,max(l,tm+1),r))+t[v].second;
        }
    }
};
/*********************************************************************/
//Sliding RMQ in O(N)
void maxSlidingWindow(int A[], int n, int w, int B[]) {
  deque<int> Q;
  for (int i = 0; i < w; i++) {
    while (!Q.empty() && A[i] >= A[Q.back()])
      Q.pop_back();
    Q.push_back(i);
  }
  for (int i = w; i < n; i++) {
    B[i-w] = A[Q.front()];
    while (!Q.empty() && A[i] >= A[Q.back()])
      Q.pop_back();
    while (!Q.empty() && Q.front() <= i-w)
      Q.pop_front();
    Q.push_back(i);
  }
  B[n-w] = A[Q.front()];
}
/**************************** NUMBER THEORY ***************************/
//Generate Highly Composite Numbers
// for each HCN i, no number less than or equal i has more divisors than i.
bool p[MAXN];
vector<int> primes;

void build(void) {
	memset(p, true, sizeof(p));

	for (int i = 2; i <= MAXN; i++) {
		if (p[i]) {
			primes.push_back(i);
			for (int j = i * i; j <= MAXN; j += i) {
				p[j] = false;
			}
		}
	}
}

int func(Int x) {
	int ans = 1;

	for (int i = 0; i < (int) primes.size() && x > 1; i++) {
		if (x % primes[i] == 0) {
			int curr = 0;
			while (x % primes[i] == 0) {
				x /= primes[i];
				curr += 1;
			}
			ans *= (curr + 1);
		}
	}
	return ans;
}

set<Int> st;

void go(int id, Int v, int last) {
	Int base = primes[id];
	if (v > MAXV) return;
	st.insert(v);

	for (int i = 0; i <= last; i++) {
		v *= (Int) base;
		if (v > MAXV) break;
		go(id + 1, v, i);
	}
}
vector<Int> ans;

for (set<Int>::iterator it = st.begin(); it != st.end(); it++) {
	int s = func(*it);
		if (s > curr) {
		ans.push_back(*it);
		curr = s;
	}
}

/*********************************************************************/
//Contando a soma de todos os numeros do intervalo sum(a, b)
public static int sum(int a, int b) {
	a -= 1;
	return ((b * (b + 1)) / 2) - (((a) * (a + 1)) / 2);
}
//*******************************************************
//modpow(a, n, mod) - calcula a^n % mod de maneira eficiente
int modpow(int a, int n, int mod) {
	int res(1);
        while (n) {
                if (n&1)
                        res=(res*a)%mod;
                a=(a*1ll*a)%mod;
                n>>=1;
        }
        return res;
}
//*******************************************************
//Calculando n-th numero de fibonnaci em O(n)
static double inverseSqrt5 = 1 / sqrt(5);
static double phi = (1 + sqrt(5)) / 2;

ll func(ll n) {
    return (ll) floor(pow(phi, n) * inverseSqrt5 + 0.5);
}
//*******************************************************
//Exponenciação rápida O(log(n))
int binpow (int a, int n) {
	int res = 1;
	while (n) {
		if (n & 1)
			res *= a;
		a *= a;
		n >>= 1;
	}
	return res;
}
//*******************************************************
//Contando o numero de divisores inteiros de um determinado nume 'N' O(sqrt(N))
int ct(int n) {
    if(n == 1) return 1L;

    int x = (int) sqrt(n);
    int counter = 0;

    for(int i = 1; i <= x; i++) {
        if(n % i == 0) {
            counter += 2;
        }
    }
    if(x * x == n) counter -= 1;
    return counter;
}
//*******************************************************
//Todos os divisores de 2 numeros, interseccao entre ambos
void gen(vector<int>& ans, vector<pair<int, int> >& v, int id, int x, int N) {
    if (id == N) {
        ans.push_back(x);
    } else {
        for (int i = 0; i <= v[id].second; i++) {
            gen(ans, v, id + 1, x, N);
            x *= v[id].first;
        }
    }
}

vector<int> func(int x) {
    vector<pair<int, int> > vp;

    int d = 1;

    for (int i = 2; i * i <= x; i += d, d = 2) {
        if (x % i == 0) {
            vp.push_back(make_pair(i, 0));

            for ( ; x % i == 0; ) {
                vp.back().second += 1;
                x /= i;
            }
        }
    }
    if (x != 1) {
        vp.push_back(make_pair(x, 1));
    }

    vector<int> ans;

    gen(ans, vp, 0, 1, (int) vp.size());

    return ans;
}

vector<int> d1 = func(A);
vector<int> d2 = func(B);

sort(d1.begin(), d1.end());
sort(d2.begin(), d2.end());

set_intersection(d1.begin(), d1.end(), d2.begin(), d2.end(), inserter(dv, dv.begin()));
//Checando se um numero é primo ou não
bool isPrime(long long n) {
    if(n <= 1) return false;
    if(n == 2) return true;
    if(n % 2 == 0) return false;

    long long m = (long long) sqrt(n);

    for(i = 3L; i <= m; i += 2L) {
        if(n % i == 0) {
            return false;
        }
    }
    return true;
}
//*******************************************************
//Crivo de Erastotenes Eficiente
const int N = 10000000;
int lp[N+1];
vector<int> pr;

for(int i = 2; i <= N; ++i) {
	if(lp[i] == 0) {
		lp[i] = i;
        pr.push_back(i);
    }
    for(int j = 0; j < (int) pr.size() && pr[j] <= lp[i] && i * pr[j] <= N; ++j) {
		lp[i * pr[j]] = pr[j];
    }
}
//*******************************************************
//Crivo de Erastotenes Comum - (Todos os numeros primes <= N)
bool sieve(int n) {
	bool prime[n+1];
	fill(prime, prime + n + 1,true);
	prime[0] = false;
	prime[1] = false;

	int m = (int) sqrt(n);

	for(int i = 2; i <= m; i++) {
		if(prime[i]) {
			for (int k=i*i; k<=n; k+=i) {
				prime[k]=false;
			}
		}
	}
	return prime;
}
//*******************************************************
//Problema de Josephus (ultimo a ser removido do circulo, removendo de D em D)
int N, D;

int func(void) {
    int r = 0, i = 2;

    while (i <= N) {
        r = (r + D) % i;
        i += 1;
    }

    return r + 1;
}
//*******************************************************
//Little Fermat Primarity test - (Testar se um numero e primo de maneira eficiente
BigInteger getRandomFermatBase(BigInteger n) {
	while(true) {
		final BigInteger a = new BigInteger (n.bitLength(), rand);
		if (BigInteger.ONE.compareTo(a) <= 0 && a.compareTo(n) < 0) {
			return a;
		}
	}
}

public static boolean checkPrime(BigInteger n, int maxIterations) {
	if(n.equals(BigInteger.ONE)) {
		return false;
	}
	for (int i = 0; i < maxIterations; i++) {
		BigInteger a = getRandomFermatBase(n);
		a = a.modPow(n.subtract(BigInteger.ONE), n);
		
		if (!a.equals(BigInteger.ONE)) {
			return false;
		}
	}
	return true;
}
//*******************************************************
//Soma de todos os divisores de um numero
vector<int> primes;

void build(void) {
    vector<int> memo(N+5, 1); memo[0] = memo[1] = 0;

    for(int i = 2; i <= (int) sqrt(N); i++) if(memo[i] == 1) {
        for(int j = i * i; j <= N; j += i) {
            memo[j] = 0;
        }
    }

    for(int i = 2; i <= N; i++) if(memo[i]) primes.push_back(i);
}

void mount(int x) {
    vector<int> fact;
    int base = 0, other = x, mult = 1;
    while(x > 1) {
        int cnt = 0;
        while(base < primes.size() && x % primes[base] == 0) {
            x /= primes[base];
            cnt += 1;
        }
        if(cnt) {
            mult *= (((int) pow(primes[base], cnt + 1) - 1) / (int) (primes[base] - 1));
        }
        base += 1;
    }
    sum[other] = mult - other;
}

//*******************************************************
//GCD - Maximo Divisor Comum
int gcd(int a, int b) {
	if(b == 0) return a;
	return gcd(b, a % b);
}
//*******************************************************
//LCM - Minimo Multiplo Comum
int lcm(int a, int b) {
	return a * b / gcd(a, b);
}
//*******************************************************
//Euler Phi Function (Get coprime numbers)
//*******************************************************
#include <iostream>
#include <limits.h>
#include <cstdlib>
#include <cmath>
using namespace std;

const int N1 = 50001, N2 = 5133;
bool isPrime[N1];
int prime[N2], nPrime, totient[N1];

void sieveAndTotient() {
    // reset
    for (int i = 0; i < N1; ++i)
        totient[i] = i;
    isPrime[0] = isPrime[1] = false;
    for (int i = 3; i < N1; i += 2)
        isPrime[i] = true;
    for (int i = 4; i < N1; i += 2)
        isPrime[i] = false;
    nPrime = 0;
    // 2
    // update for 2
    prime[nPrime++] = 2;
    for (int j = 2; j < N1; j += 2) {
        isPrime[j] = false;
        // totient for 2
        totient[j] -= totient[j] / 2;
    }
    isPrime[2] = true;
    // odds
    for (int i = 3; i < N1; i += 2)
        if (isPrime[i]) {
            // update for i
            prime[nPrime++] = i;
            if (i < INT_MAX)
                for (int j = i; j < N1; j += i) {
                    isPrime[j] = false;
                    // totient for i
                    totient[j] -= totient[j] / i;
                }
            isPrime[i] = true;
        }
}

int main() {
    sieveAndTotient();
    int in;
    while (cin >> in)
        cout << totient[in] << endl;
    return 0;
}
//*******************************************************
//Euler Phi Function (Get coprime numbers) - Faster
 int fi(int n)
     {
       int result = n;
       for(int i=2;i*i <= n;i++)
       {
         if (n % i == 0) result -= result / i;
         while (n % i == 0) n /= i;
       }
       if (n > 1) result -= result / n;
       return result;
     }

//*******************************************************
//Fast method to get factorial of N MOD P, in O(N log(P))
//*******************************************************
int factmod (int n, int p) {
	int res = 1;
	while (n > 1) {
		res = (res * ((n/p) % 2 ? p-1 : 1)) % p;
		for (int i=2; i<=n%p; ++i)
			res = (res * i) % p;
		n /= p;
	}
	return res % p;
}
//*******************************************************
//Euler phi function using less memory
//*******************************************************
#include <cstdio>
using namespace std;

typedef long long int64;

int64 totient(int64 n) {
    if (n == 1)
        return 1ll;
    int64 out = n;
    // 2
    if (n % 2 == 0) {
        out -= out / 2;
        do
            n /= 2;
        while (n % 2 == 0);
    }
    // odds
    for (int i = 3; i * i <= n; i += 2)
        if (n % i == 0) {
            out -= out / i;
            do
                n /= i;
            while (n % i == 0);
        }
    //
    if (n > 1)
        out -= out / n;
    return out;
}

int main() {
    int64 n;
    scanf("%lld", &n);
    printf("%lld\n", totient(n));
    return 0;
}
/* ***************************** BASE TRANSFORMATIONS ********************* */
//Chega se o digito corresponde a base numerica indicada
boolean isFromBase(char digit, int base) {
	if (digit >= 'A' && digit - 'A' + 10 >= base) {
		return false;
	} else if (digit < 'A' && digit - '0' >= base) {
		return false;
	} else {
		return true;
	}
}

//Qualuqer base para decimal
public int anyBaseToDec(String num, int fromBase) {
	int ans = 0;
	int n = num.length();
	for (int i = 0; i < num.length(); i++) {
		if (!isFromBase(num.charAt(i), fromBase)) return -1;
		if (num.charAt(i) >= 'A') {
			ans += (num.charAt(i) + 10 - 'A') * (modpow(fromBase, n - i - 1));
		} else {
			ans += (num.charAt(i) - '0') * (modpow(fromBase, n - i - 1));
		}
	}
	return ans;
}


//Decimal para outras bases
public String decToOthers(int value, int toBase) {
	if (value == 0) return "0";
	String ans = "";
	while (value > 0) {
		int aux = (value % toBase);
		if (aux > 9) {
			ans = (char) ('A' - 9 + aux - 1) + ans;
		} else {
			ans = (char) (aux + '0') + ans;
		}
		value /= toBase;
	}
	return ans;
}
