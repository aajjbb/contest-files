//*******Guia de Referencia-Maratona-Jeferson-Vinicius**********//
//**********************************************
//QuickSort O(N log N) worst case O(n^2)
#include <iostream>
#include <vector>

using namespace std;

#define MAXN 10000

int n, a[MAXN];


void quicksort(int lo, int hi) {
    int i=lo, j=hi, h;

    int x=a[(lo+hi)/2];

    do {
        while (a[i]<x) i++;
        while (a[j]>x) j--;
        if (i<=j) {
            swap(a[i], a[j]);
            i++;
            j--;
        }
    } while (i<=j);

    if (lo<j) quicksort(lo, j);
    if (i<hi) quicksort(i, hi);
}
//**********************************************
//Merge-Sort O(N log N)
vector<int> merge(vector<int>& b, vector<int>& c) {
	vector<int> a;

	while(!b.empty() && !c.empty()) {
		if(*b.begin() < *c.begin()) {
			a.push_back(*b.begin());
			b.erase(b.begin());
		} else if(*b.begin() > *c.begin()) {
			a.push_back(*c.begin());
			c.erase(c.begin());
		} else {
			a.pb(*b.begin());
			a.pb(*c.begin());
			b.erase(b.begin());
			c.erase(c.begin());
		}
	}
	while(!b.empty()) { a.pb(*b.begin()); b.erase(b.begin()); }
	while(!c.empty()) { a.pb(*c.begin()); c.erase(c.begin()); }
	return a;
}

vector<int> mergeSort(vector<int>& a) {
	if(sz(a) <= 1) {
		return a;
	}
	vector<int> b;
	vector<int> c;

	for(int i = 0; i < sz(a) / 2; i++) {
		b.pb(a[i]);
	}
	for(int i = sz(a) / 2; i < sz(a); i++) {
		c.pb(a[i]);
	}
	vector<int> sb = mergeSort(b);
	vector<int> sc = mergeSort(c);
	return merge(sb, sc);
}
//**********************************************
//Heapsort O(N log N)
#include <iostream>
#include <vector>

using namespace std;

#define MAXN 10000

int n, a[MAXN];

void downheap(int v) {
    int w = 2*v+1;
    while(w < n) {
        if(w + 1 < n) {
            if (a[w+1]>a[w]) w++;
        }
        if(a[v] >= a[w]) return;
        swap(a[v], a[w]);
        v = w;
        w = 2*v+1;
    }
}

void buildheap() {
    for (int v = n/2-1; v >= 0; v--) {
        downheap (v);
    }
}

void heapsort() {
    buildheap();
    while (n>1) {
        n--;
        swap(a[0], a[n]);
        downheap (0);
    }
}
//**********************************************
//Pesquisa Binaria:[BIN]
void search(int x) {
	int low = 0, high = INF, mid;

	while(low < high) {
		mid = low + (high - low) / 2;
		if(satisfied) {
			//High bound
			low = mid + 1;
		} else {
			high = mid;
		}
	}
	return low;
}
//**********************************************
//Pesquisa Binaria com Numeros Reais:[BINR]
void search(double x) {
	//Real numbers are dense, set a bound rather then wait for the condition (low < high) be satisfied
	int low = 0, high = INF, mid;
	for(int i = 0; i <= 100; i++) {
		mid = low + (high - low) / 2;
		if(satisfied) {
			low = mid;
		} else {
			high = mid;
		}
	}
	return low;
}
//**********************************************
//Split empty spaces in string
void split(vector<string>& v, const string& s) {
    istringstream ss(s, istringstream::in);
    v.clear(); string t;
    while(ss >> t) {
        v.push_back(t);
    }
}
//**********************************************
KMP
vector<int> KMP(string S, string K) {
    vector<int> T(K.size() + 1, -1);
    vector<int> matches;

    if(K.size() == 0) {
        matches.push_back(0);
        return matches;
    }
    for(int i = 1; i <= K.size(); i++) {
        int pos = T[i - 1];
        while(pos != -1 && K[pos] != K[i - 1]) pos = T[pos];
        T[i] = pos + 1;
    }

    int sp = 0;
    int kp = 0;
    while(sp < S.size()) {
        while(kp != -1 && (kp == K.size() || K[kp] != S[sp])) kp = T[kp];
        kp++;
        sp++;
        if(kp == K.size()) matches.push_back(sp - K.size());
    }

    return matches;
}
//**********************************************
Suffix Array
#define max 100010

int delta, len, SA[max], iSA[max], val[max], tval[max];
char s[max];
bool cmp(const int& a, const int& b) {
    return val[a+delta] < val[b+delta];
}

void build_SA() {
    int i, j;
    for (i=0; i<len; i++) val[i] = s[i];
    for (i=0; i<len; i++) SA[i] = i;

    delta = 0;
    sort(SA, SA+len, cmp);

    for(delta = 1; ; delta *= 2) {
        bool found = false;
        for(i = 0; i < len; i++) {
            for(j = i + 1; j < len; j++) if(val[SA[i]] != val[SA[j]]) break;
            if (j > i+1) {
                found = true;
                sort(SA+i, SA+j, cmp);
            }
            i = j - 1;
        }

        if(!found) break;
        tval[SA[0]] = 0;
        for(i = 1; i < len; i++) {
            tval[SA[i]] = tval[SA[i-1]];
            if(val[SA[i]] == val[SA[i-1]] && val[SA[i]+delta] == val[SA[i-1]+delta]);
            else tval[SA[i]]++;
        }
        memcpy(val, tval, len * sizeof(int));
    }
}

build_SA();
for (int i = 0; i < len; i++) printf("%d\n", SA[i]);
/* ******************************* GRAPH ************************* */
//Pesquisa em profundidade simples em Grafo - [DFS]:
void dfs(int x) {
    vis[x] = 1;
    for(int i = 1; i <= n; i++) {
        if(vis[i] == 0 && matrix[x][i] == 1) dfs(i);
    }
}
//**********************************************
//Pesquisa em largura simples em Grafo - [BFS] -> Utilizando 'dist' para guardar o menor caminho e 'x' -> 'i', já que as arestas tem pesos iguais:
//N = Numero maximo de Vertices no grafo
void bfs(int x) {
	int dist[N], vis[N]; memset(dist, 0, sizeof(dist)); memset(vis, 0, sizeof(vis));
	queue<int> q;
	q.push(x);
	vis[x] = true;
	dist[x] = 0;

	while(!q.empty()) {
		int tmp = q.front(); q.pop();
		vis[tmp] = true;

		for(int i = 1; i <= N; i++) {
			if(!vis[i] && matrix[tmp][i]) {
				q.push(i);
				dist[i] = dist[tmp] + 1;
			}
		}
	}
}
//**********************************************
//Ordenação topologica simples: [OTS]
void dfs(int x) {
    used[x] = 1;
    for(int b = 0; b < g[x].size(); b++) {
        if(!used[g[x][b]]) dfs(g[x][b]);
    }
    order.push_back(x);
}

//Ordenação topologica com checagem de ciclos: [OTCC]
//Se a variavel has se tornar verdade, o grafo contem um ciclo.
void dfs(int x) {
    vis[x] = 1;
    for(int u = 0; u < n; u++) {
        if(vis[u] == 1 && graph[x][u] == 1) has = true;
        if(vis[u] == 0 && graph[x][u] == 1) {
            dfs(u);
        }
    }
    vis[x] = 2;
    order.push_back(x);
}

//**********************************************
//Componentes fortemente conectados: [CFC]

Matrix ga -> Matrix original
Matrix gb -> Matrix transposta:

Primeiro Ordena-se topologicamente os vertices, depois faz-se a checagem da quantidade e componentes em um
componente fortemente conectado em um grafo direcionado:


//Ordena topologicamente os vertices da matrix original, e guarda a ordem no vector order
void dfs1(int x) {
    used[x] = 1;
    for(int b = 0; b < g[x].size(); b++) {
        if(!used[g[x][b]]) dfs1(g[x][b]);
    }
    order.push_back(x);
}

//Procura por comoponentes fortemente conectados e guarda seus vertices no set component, usando a matrix transposta 'gr'
void dfs2(int x) {
    used[x] = 1;
	comoponent.insert(x);
    for(int b = 0; b < gr[x].size(); b++) {
        if(!used[gr[x][b]]) dfs2(gr[x][b]);
    }
}

//Rodando as buscas:
//Ordenando Topologicamente
for(i = 1; i <= n; i++) if(!used[i]) dfs1(i);

//Procura pelos componentes:
//A variavel "ans" guarda a quantidade de componentes conectados no grafo.
for(i = 0; i < order.size(); i++) {
    int v = order[i];
	if(!used[v]) {
		dfs2(v);
        ans++;
        component.clear();
	}
}
//**********************************************
Procurando por Ciclos Negativos
struct edge {
	int a, b, cost;
};

int n, m;
vector<edge> e;
const int INF = 1000000000;

void solve() {
	vector<int> d (n);
	vector<int> p (n, -1);
	int x;
	for (int i=0; i<n; ++i) {
		x = -1;
		for (int j=0; j<m; ++j)
			if (d[e[j].b] > d[e[j].a] + e[j].cost) {
				d[e[j].b] = max (-INF, d[e[j].a] + e[j].cost);
				p[e[j].b] = e[j].a;
				x = e[j].b;
			}
	}

	if (x == -1)
		cout << "No negative cycle found.";
	else {
		int y = x;
		for (int i=0; i<n; ++i)
			y = p[y];

		vector<int> path;
		for (int cur=y; ; cur=p[cur]) {
			path.push_back (cur);
			if (cur == y && path.size() > 1)  break;
		}
		reverse (path.begin(), path.end());

		cout << "Negative cycle: ";
		for (size_t i=0; i<path.size(); ++i)
			cout << path[i] << ' ';
	}
}

//********************************************
//Determinando se um grafo é bipartido ou não:
//Sendo 'gr' a matrix de adjacencia representando o Grafo.
bool dfs(int node, int c) {
    if(color[node] != 0) {
        if(color[node] == c) {
            return true;
        } else {
            return false;
        }
    }
    color[node] = c;
    for(int i = 1; i <= n; i++) if(gr[node][i] == 1) {
        if(!dfs(i, -c)) {
            return false;
        }
    }
    return true;
}

//Fazendo a pesquisa
// Caso o Grafo seja '1' base
dfs(1, 1);
//Senão
dfs(0, 1);

//******************************************
Multiplicação de Matrizes
vector<vector<int> > multiply(vector<vector<int> > a, vector<vector<int> > b) {
	vector<vector<int> > res(c, vector<int>(c));
	for(int i = 0; i < c; i++) {
		for(int j = 0; j < c; j++) {
			int sum = 0;
			for (int k = 0; k < c; k++) {
				sum |= a[i][k] & b[k][j];
			}
			res[i][j] = sum;
		}
	}
	return res;
}

vector<vector<int> > binPow(vector<vector<int> > a, int n) {
	if (n == 1)
		return a;
	if ((n & 1) != 0)
		return multiply(a, binPow(a, n - 1));
	else {
		vector<vector<int> > b = binPow(a, n / 2);
		return multiply(b, b);
	}
}
//******************************************
//Minimum Spanning Trees ->
//Kruskal Algorithm
struct edge {
    int from, to, cost;
    edge() {}
    edge(int from, int to, int cost): from(from), to(to), cost(cost) {};

    bool operator<(const edge& e) const {
		return cost < e.cost;
    }
};
//Sendo 'M' o numero de arestas, 'u' uma implementação do conjunto disjunto 'UnionFind' e 'ans' o menor custo
vector<edge> edges; //Populado com as arestas
int ans = 0;
for(i = 0; i < m; i++) {
	if(!u.find(edges[i].from, edges[i].to)) {
		u.unite(edges[i].from, edges[i].to);
		ans += edges[i].cost;
	}
}
//Prim Algorithm
int g[MAXN][MAXN], used[MAXN], min_e[MAXN], sel_e[MAXN];
min_e[0] = 0;
for (int i = 0; i < n; ++i) {
	int v = -1;
	for(int j = 0; j < n; ++j) {
		if (!used[j] && (v == -1 || min_e[j] < min_e[v])) {
			v = j;
		}
	}
	used[v] = true;
	if (sel_e[v] != -1) {
		ans += min_e[v];
	}
	for (int to = 0; to < n; ++to) {
		if (g[v][to] < min_e[to]) {
			min_e[to] = g[v][to];
			sel_e[to] = v;
		}
	}
}
//*********************************************

//LCA O(<Nlog(N)>, <log(N)>)


int N, Q, A, B;
vector<pair<int, int> > adj[MAXN];
int parent[MAXN], L[MAXN], vis[MAXN];
vector<int> level[MAXN];
int P[MAXN][20];
Int dist[MAXN];

void dfs(int pos, int par){
    if(parent[pos] == -1){
        parent[pos] = par;

        for(int i = adj[pos].size() - 1,to;i >= 0;--i){
            to = adj[pos][i].first;
            if(to != par) {
                dist[to] = dist[pos] + adj[pos][i].second;
                dfs(to,pos);
            }
        }
    }
}

int get_level(int u){
    if(L[u]!=-1) return L[u];
    else if(parent[u]==-1) return 0;
    return 1+get_level(parent[u]);
}

void init(){
  for(int i = 0;i<N;++i) L[i] = get_level(i);

  for(int i = 0;i < N;++i) level[L[i]].push_back(i);

  memset(P,-1,sizeof(P));

  for(int i = 0;i<N;++i) P[i][0] = parent[i];

  for(int j = 1;(1<<j)<N;++j)
      for(int i = 0;i<N;++i)
        if(P[i][j-1]!=-1)
          P[i][j] = P[P[i][j-1]][j-1];
}

int LCA(int p, int q){
    if(L[p]<L[q]) swap(p,q);

    int log = 1;
    while((1<<log)<=L[p]) ++log;
    --log;

    for(int i = log;i>=0;--i)
        if(L[p]-(1<<i)>=L[q])
            p = P[p][i];

    if(p==q) return p;

    for(int i = log;i>=0;--i){
        if(P[p][i]!=-1 && P[p][i]!=P[q][i]){
            p = P[p][i];
            q = P[q][i];
        }
    }

    return parent[p];
}

for (i = 0; i <= N; i++) {
            vis[i] = 0;
            L[i] = parent[i] = -1;
            dist[i] = 0LL;
            adj[i].clear();
	    }
		for (i = 1; i < N; i++) {
			scanf("%d%d", &t, &l);
			adj[i].push_back(make_pair(t, l));
			adj[t].push_back(make_pair(i, l));
		}

        dfs(0, -2);
		parent[0] = -1;

		init();


//*********************************************

//Dijkstra
struct MyLess {
    bool operator()(int x, int y) {
        return dist[x] > dist[y];
    }
};

int dijsktra(int source, int destiny) {
	for(int i = 0; i <= 110; i++) {
		dist[i] = INT_MAX;
	}
	priority_queue<int, vector<int>, MyLess> q;
	dist[source] = 0;
 	q.push(source);

	while(!q.empty()) {
		int tmp = q.top(); q.pop();
		for(int i = 0; i < graph[tmp].size(); i++) {
            int aux_dist = dist[tmp] + graph[tmp][i].second;
            int actual_dist = dist[graph[tmp][i].first];
            if(aux_dist < actual_dist) {
                dist[graph[tmp][i].first] = aux_dist;
                q.push(graph[tmp][i].first);
            }
        }
    }
	return dist[destiny];
}
//Reconstrução do Caminho
vector<int> path;
int start = destiny;

while(start != -1) {
	path.push_back(start);
	start = prev[start];
}
//*******************************************************
//Bellman-Ford
#define INFINITY 0x3f3f3f3f
#define MAXN 1000

using namespace std;

typedef struct {
    int source;
    int dest;
    int weight;
} edge;

int N, M, dist[MAXN];

void bellmanford(vector<Edge> edges, int source) {
    int i,j,change;
    for (i = 0; i < N; i++) {
        dist[i] = INFINITY;
    }
    dist[source]=0;
    for (i = 0; i < N; i++) {
        change = 0;
        for (j = 0; j < M; j++) {
            if (dist[edges[j].dest] > dist[edges[j].source] + edges[j].weight) {
                dist[edges[j].dest] = dist[edges[j].source] + edges[j].weight;
                change=1;
            }
        }
        if (change==0) break;
    }
    for (i = 0; i < M; i++) {
        if (dist[edges[i].dest] > dist[edges[i].source] + edges[i].weight) {
            //Negative Cycle
            break;
        }
    }
}
//*******************************************************
//Contando Pontes em um Grafo não Direcionado
int a, b, n, m, cont, ct, vis[1010], nivel[1010], menor[1010], pai[1010];
vector<int> graph[1010];
void dfs(int x) {
	vis[x] = 1;
	nivel[x] = menor[x] = cont++;
	int sons = 0;
	for(int i = 0; i < graph[x].size(); i++) {
		if(vis[graph[x][i]] == 0) {
		sons += 1;
		pai[graph[x][i]] = x;
		dfs(graph[x][i]);
		if(menor[graph[x][i]] < menor[x]) menor[x] = menor[graph[x][i]];
			if(menor[graph[x][i]] == nivel[graph[x][i]]) {
				ct++;
			}
		} else if(vis[graph[x][i]] == 1 && pai[x] != graph[x][i]) {
			if(nivel[graph[x][i]] < menor[x]) menor[x] = nivel[graph[x][i]];
		}
	}
	vis[x] = 2;
}
ct = numero final de pontes
//*******************************************************
//Achando Vertices de Articulação um Grafo
vector<int> graph[410];
set<int> ans;
set<int>::iterator it;

int dfs(int u){
    int less = vis[u] = times++;
    int filhos = 0;
    for(int i = 0; i< graph[u].size(); i++){
       if(vis[graph[u][i]]==0){
          filhos++;
          int m = dfs(graph[u][i]);
          less = min(less,m);
          if(vis[u] <= m && (u != 0 || filhos >= 2)){
              ans.insert(u);
          }
       }else{
          less = min(less, vis[graph[u][i]]);
       }
    }
    return less;
}
//Chamando
times = 1;
ans.clear();
dfs(0);
//*******************************************************
Fluxo-Máximo - Edmonds-Karp O(N*M^2)

int max_flow(int source, int sink) {
    int residual[MAXN][MAXN]; memset(residual, 0, sizeof(residual));
    while(1) {
        int prev[MAXN]; memset(prev, -1, sizeof(prev));
        int actual[MAXN]; memset(actual, 0, sizeof(actual));
        prev[source] = source;
        actual[source] = INF;
        queue<int> q; q.push(source);
        while(!q.empty()) {
            int u = q.front(); q.pop();
            for(int i = 0; i < graph[u].size(); i++) {
                int v = graph[u][i];
                if(capacity[u][v] - residual[u][v] > 0 && prev[v] == -1) {
                    prev[v] = u;
                    actual[v] = min(actual[u], capacity[u][v] - residual[u][v]);
                    if(v != sink) {
                        q.push(v);
                    } else {
                        while(prev[v] != v) {
                            u = prev[v];
                            residual[u][v] += actual[sink];
                            residual[v][u] -= actual[sink];
                            v = u;
                        }
                        goto end;
                    }
                }
            }
        }
        end:;
        if(prev[sink] == -1) {
            int sum = 0;
            for(int i = 0; i < MAXN; i++) {
                sum += residual[source][i];
            }
            return sum;
        }
    }
}
//Montagem do Grafo
memset(capacity, 0, sizeof(capacity));
int n, m, a, b, c;
scanf("%d%d", &n, &m); //Tamanho/Numero de Arestar
for(int i = 0; i < m; i++) {
	scanf("%d%d%d", &a, &b, &c); //DE-PARA-CUSTO
	graph[a].push_back(b); capacity[a][b] += c;
	graph[b].push_back(a); capacity[b][a] += c;
}
//*******************************************************
//Max Flow dinic O(V^2*E)
map<int, int> v[1000];
typedef map<int, int>::iterator iter;
int n;

int bfs(int s, int t) {
        queue<pair<int, int> > q;
        int visit[n];
        fill(visit,visit+n,0);
        q.push(make_pair(s, 0));
        while (!q.empty()) {
                int tmp = q.front().first;
                int level = q.front().second;
                if (tmp == t) return level;
                q.pop();
                if (!visit[tmp]) {
                        visit[tmp] = 1;
                        for (map<int, int>::iterator it = v[tmp].begin();
                                        it != v[tmp].end(); it++)
                        {
                                if (it->second > 0 && !visit[it->first])
                                        q.push(make_pair(it->first, level + 1));
                        }
                }
        }
        return 0;
}

int dfs(int s, int t, int lv, vector<int> *cf) {
        int tmp;
        if (s == t) {
                int min = INT_MAX;
                for (vector<int>::iterator it = cf->begin(); it != cf->end(); it++)
                        if (min > *it) min = *it;
                return min;
        }
        if (lv == 0) return 0;
        for (iter it = v[s].begin(); it != v[s].end(); it++) {
                cf->push_back(it->second);
                if (it->second > 0 && (tmp = dfs(it->first, t, lv - 1, cf))) {
                        it->second -= tmp;
                        if (v[it->first].find(s) != v[it->first].end()) v[it->first].insert(
                                        make_pair(s, tmp));
                        else v[it->first][s] -= tmp;
                        return tmp;
                }
                cf->pop_back();
        }
        return 0;
}

int augment(int s, int t, int lv) {
        int sum = 0;
        int tmp;
        while ((tmp = dfs(s, t, lv, new vector<int>))) {
                sum += tmp;
        }
        return sum;
}

int maxflow(int s, int t) {
        int sum = 0;
        int level;
        while ((level = bfs(s, t))) {
                sum += augment(s, t, level);
        }
        return sum;
}

int main() {
        int e, s, t;
        int a, b, w;
        cin >> n >> e >> s >> t;
        for (int i = 0; i < e; i++) {
                cin >> a >> b >> w;
                v[a].insert(make_pair(b, w));
        }
        cout << maxflow(s, t) << endl;
        return 0;
}
//*******************************************************
//*******************************************************
//Bipartição Maxima em um grafo
int n, k;
vector<vector<int> > g;
vector<int> mt;
vector<char> used;

bool try_kuhn(int v) {
	if (used[v])  return false;
	used[v] = true;
	for (size_t i=0; i<g[v].size(); ++i) {
		int to = g[v][i];
		if (mt[to] == -1 || try_kuhn(mt[to])) {
			mt[to] = v;
			return true;
		}
	}
	return false;
}
mt.assign (k, -1);
for (int v=0; v<n; ++v) {
	used.assign (n, false);
	try_kuhn (v);
}

for (int i=0; i<k; ++i)
	//Imprime as bipartições
	if (mt[i] != -1)
		printf ("%d %d\n", mt[i]+1, i+1);

//*******************************************
//Floyd-Warshall - Menor Caminho de todos para todos - O(N^3)
//Sendo 'dist[][]' a matrix de adjacencia com os pesos entre os vertices conectados 'i' e 'j' e os demais valores como '-INF'
// dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
// Distancia minima do vertice 'i' ao vertice 'j' utilizando arestas entre '0' e 'k';

for(int k = 0; k < n; k++) {
	for(int i = 0; i < n; i++) {
		for(int j = 0; j < n; j++) {
			dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
		}
	}
}
//*******************************************
Corte Minimo em um grafo Stoer-Wager O(N^3)
int graph[MAXN][MAXN] //Matrix de Adjacencia do grafo.
int minCut(int n) {
    bool a[n];
    int v[n];
    int w[n];
    for(int i = 0; i < n; i++) v[i] = i;
    int best = INF;
    while(n > 1) {
        int maxj = 1;
        a[v[0]] = true;
        for(int i = 1; i < n; ++i) {
            a[v[i]] = false;
            w[i] = graph[v[0]][v[i]];
            if(w[i] > w[maxj]) {
                maxj = i;
            }
        }
        int prev= 0 ,buf = n;
        while(--buf) {
            a[v[maxj]]=true;
            if(buf == 1) {
                best = min(best, w[maxj]);
                for(int k = 0; k < n; k++) {
                    graph[v[k]][v[prev]]= (graph[v[prev]][v[k]] += graph[v[maxj]][v[k]]);
                }
                v[maxj] = v[--n];
            }
            prev = maxj;
            maxj = -1;
            for(int j = 1; j < n; ++j) {
                if(!a[v[j]]) {
                    w[j] += graph[v[prev]][v[j]];
                    if(maxj < 0 || w[j] > w[maxj]) {
                        maxj=j;
                    }
                }
            }
        }
    }
    return best;
}
//*******************************************
//Maximimum Flow - Edward-Karp Method
/**
 * Finds the maximum flow in a flow network.
 * @param E neighbour lists
 * @param C capacity matrix (must be n by n)
 * @param s source
 * @param t sink
 * @return maximum flow
 */

int flow(vector<int> e[], vector<int> c[], int s, int t) {
	int n = C.length;
	// Residual capacity from u to v is C[u][v] - F[u][v]
   int[][] F = new int[n][n];
   while (true) {
   	int[] P = new int[n]; // Parent table
   	fill(P.begin(), P.end(), -1);
      P[s] = s;
      int M[n]; // Capacity of path to node
      M[s] = INF

		queue<int> q;
		q.push(s);
      while (!q.empty()) {
      	int u = q.front(); q.pop();
      	for (int v : E[u]) {
         // There is available capacity,
         // and v is not seen before in search
         if (C[u][v] - F[u][v] > 0 && P[v] == -1) {
         	P[v] = u;
            M[v] = min(M[u], C[u][v] - F[u][v]);
            if(v != t) {
            	q.push(v);
				} else {
           	// Backtrack search, and write flow
            	while (P[v] != v) {
               	u = P[v];
               	F[u][v] += M[t];
               	F[v][u] -= M[t];
               	v = u;
               }
               goto end;
				}
			}
		}
		end:;if (P[t] == -1) { // We did not find a path to t
			int sum = 0;
      	for (int x : F[s]) {
      		sum += x;
			}
         return sum;
		}
	}
}

//Fluxo Maximo de Custo Minimo
const int MAXN = 110;
const Int INF = 901010100101010LL;

Int cap[MAXN][MAXN], cost[MAXN][MAXN], fnet[MAXN][MAXN], adj[MAXN][MAXN], deg[MAXN], par[MAXN], d[MAXN], pi[MAXN];

bool dijkstra(int n, int s, int t) {
    for(int i = 0; i < n; i++) d[i] = INF, par[i] = -1;
    d[s] = 0;
    par[s] = -n - 1;

    while(1) {
        Int u = -1, bestD = INF;

        for(int i = 0; i < n; i++) if(par[i] < 0 && d[i] < bestD) bestD = d[u = i];

        if(bestD == INF) break;

        par[u] = -par[u] - 1;

        for(int i = 0; i < deg[u]; i++) {
            int v = adj[u][i];

            if(par[v] >= 0LL) continue;

            if(fnet[v][u] && d[v] > (d[u] + pi[u] - pi[v]) - cost[v][u]) {
                d[v] = (d[u] + pi[u] - pi[v]) - cost[v][u], par[v] = -u - 1;
            }

            if(fnet[u][v] < cap[u][v] && d[v] > (d[u] + pi[u] - pi[v]) + cost[u][v]) {
                d[v] = (d[u] + pi[u] - pi[v]) + cost[u][v], par[v] = -u - 1;
            }
        }
    }

    for(int i = 0; i < n; i++) if(pi[i] < INF) pi[i] += d[i];

    return par[t] >= 0LL;
}

int mcmf3(int n, int s, int t, Int &fcost) {
    memset(deg, 0LL, sizeof(deg));

    for(int i = 0; i < n; i++) {
        for(int j = 0; j < n; j++) {
            if(cap[i][j] || cap[j][i]) {
                adj[i][deg[i]++] = j;
            }
        }
    }

    memset(fnet, 0LL, sizeof(fnet));
    memset(pi, 0LL, sizeof(pi));

    Int flow = fcost = 0LL;

    while(dijkstra(n, s, t)) {
        Int bot = INF;
        for(int v = t, u = par[v]; v != s; u = par[v]) {
            bot = min(bot, (Int) (fnet[v][u] ? fnet[v][u] : (cap[u][v] - fnet[u][v])));
            v = u;
        }
        for(int v = t, u = par[v]; v != s; u = par[v = u]) {
            if(fnet[v][u]) {
                fnet[v][u] -= bot;
                fcost -= bot * cost[v][u];
            } else {
                fnet[u][v] += bot;
                fcost += bot * cost[u][v];
            }
        }
        flow += bot;
    }
    return flow;
}

//*****************************Geometria*************************************//
//*********************************
//Distance between point - line
double dot(pair<int, int> &A, pair<int, int> &B, pair<int, int> &C) {
    return (double) (B.first - A.first) * (C.first - B.first) + (B.second - A.second) * (C.second - B.second);
}

double cross(pair<int, int> &A, pair<int, int> &B, pair<int, int> &C) {
    return (double) (B.first-A.first) * (C.second-A.second) - (B.second-A.second) * (C.first-A.first);
}

double _distance(pair<int, int> A, pair<int, int> B) {
    int d1 = A.first - B.first;
    int d2 = A.second - B.second;
    return sqrt(d1*d1+d2*d2);
}

double linePointDist(pair<int, int> A, pair<int, int> B, pair<int, int> C, bool isSegment) {
    double dist = cross(A,B,C) / _distance(A,B);
    if(isSegment) {
        int dot1 = dot(A,B,C);
        if(dot1 > 0)return _distance(B,C);
        int dot2 = dot(B,A,C);
        if(dot2 > 0)return _distance(A,C);
    }
    return abs(dist);
}
//*********************************
Cordenadas integrais em um segmento, incluindo os pontos iniciais e finais:
Segmento entre pontos (x1, y1) e (x2, y2) = gcd(abs(x1 - x2), abs(y1 - y2)) + 1

//*****************************
//Area de um Poligono Convexo
double area() {
	int N = 4;
	int[] x = { 2, -4, 5, 2 };
	int[] y = { 5, 3, 1, 5 };

	double ma = x[N - 1] * y[0], mb = x[0] * y[N - 1];

	for (int i = 0; i < N - 1; i++) {
		ma += (x[i] * y[i + 1]);
		mb += (x[i + 1] * y[i]);
	}

	double ans = Math.abs((ma - mb) * 0.5);
}
//*********************************
//Distancia em linha reta (straight line)
double euclideanDistance(int x1, x2, int y1, int y2){
	return sqrt(pow(x2 - x1, 2) + pow(y2 - y1, 2));
}
//***********************************
// distancia
double manhatanDistance(int x1, int x2, int y1, int y2){
	return abs(x1 - x2) + abs(y2 - y1);
}
//************************************
//area do circulo
double circleArea(double r){
	return (r * r) * acos(-1);
}
//**************************************
//raio do circulo
double raio(int circunferencia){
	return circunferencia / acos(-1) / 2;
}
//***************************************
//Convex Hull
struct point {
    int x, y;
    point(int x, int y): x(x), y(y){}
    point(){}
    bool operator <(const point &p) const {
        return x < p.x || (x == p.x && y < p.y);
    }
    bool operator==(const point &p) const {
        return x == p.x && y == p.y;
    }
};
ll cross(const point &O, const point &A, const point &B) {
    return (A.x - O.x) * (B.y - O.y) - (A.y - O.y) * (B.x - O.x);
}

vector<point> convex_hull(vector<point> &P) {
    int n = P.size(), k = 0;
    vector<point> H(2*n);

    sort(P.begin(), P.end());

    for (int i = 0; i < n; i++) {
        while (k >= 2 && cross(H[k-2], H[k-1], P[i]) <= /*change to < to remove equal points */ 0) k--;
        H[k++] = P[i];
    }
    for (int i = n-2, t = k+1; i >= 0; i--) {
        while (k >= t && cross(H[k-2], H[k-1], P[i]) <= /*change to < to remove equal points */ 0) k--;
        H[k++] = P[i];
    }
    H.resize(k);
    return H;
}
//***************************************
//Biblioteca de fracoes
struct fraction {
    int num, denom;
    fraction(int num, int denom): num(num), denom(denom){
    }
    fraction() { num = 0; denom = 0; }
    void reduce(fraction& f) {
        int l = gcd(f.num, f.denom);
        f.num = f.num/l;
        f.denom = f.denom/l;
    }
    fraction operator+(const fraction& f) {
        fraction ans;
        int l = lcm(denom, f.denom);
        ans.num = ((l / denom) * num) + ((l / f.denom) * f.num);
        ans.denom = l;
        reduce(ans);
        return ans;
    }
    fraction operator-(const fraction& f) {
        fraction ans;
        ans.num = num - f.num;
        ans.denom = denom - f.denom;
        reduce(ans);
        return ans;
    }
    fraction operator*(const fraction& f) {
        fraction ans;
        ans.num = num * f.num;
        ans.denom = denom * f.denom;
        reduce(ans);
        return ans;
    }
    fraction operator/(const fraction& f) {
        fraction ans;
        ans.num = num * f.denom;
        ans.denom = denom * f.num;
        reduce(ans);
        return ans;
    }
    bool operator!=(const fraction& f) {
        return num != f.num || denom != f.denom;
    }
    bool operator==(const fraction& f) {
        return num == f.num && denom == f.denom;
    }
    friend ostream &operator<<(ostream &out, fraction f) {
        out << f.num << "/" << f.denom << "\n";
        return out;
    }
    friend istream &operator>>(istream &in, fraction f) {
        in >> f.num >> f.denom;
        return in;
    }
};


//***************************************
//Polygon Area
int area = 0;
int N = lengthof(p);
//We will triangulate the polygon
//into triangles with points p[0],p[i],p[i+1]

for(int i = 1; i+1<N; i++){
    int x1 = p[i][0] - p[0][0];
    int y1 = p[i][1] - p[0][1];
    int x2 = p[i+1][0] - p[0][0];
    int y2 = p[i+1][1] - p[0][1];
    int cross = x1*y2 - x2*y1;
    area += cross;
}
return abs(cross/2.0);
//*******************************************************
//Checando se 2 segmentos se cruzam
A = y2-y1
B = x1-x2
C = A*x1+B*y1
A1x + B1y = C1
A2x + B2y = C2
double det = A1*B2 - A2*B1
if(det == 0){
	//Lines are parallel
}else{
	double x = (B2*C1 - B1*C2)/det
   double y = (A1*C2 - A2*C1)/det
}
/* ************************************ Programação Dinamica: ***************************** */
//*******************************************************
//Binomial Coefficient
bin [0][0] = 1;
  for (n = 1; n < MAXN; n++) {
    bin [n][0] = 1;
    bin [n][n] = 1;
    for (k = 1; k < n; k++) {
      bin [n][k] = bin [n - 1][k] + bin [n - 1][k - 1];
      if (bin [n][k] >= MOD) {
        bin [n][k] -= MOD;
      }
    }
  }
//*******************************************************
//String distance
int dist(string& s1, string& s2) {
    int N1 = s1.size(), N2 = s2.size();

    REP(i, N1+1) dp[i][0] = i;
    REP(i, N2+1) dp[0][i] = i;

    FOR(i, 1, N1+1) FOR(j, 1, N2+1) {
        if(s1[i-1] == s2[j-1]) {
            dp[i][j] = dp[i-1][j-1];
        } else {
            dp[i][j] = 1 + min(min(dp[i-1][j], dp[i][j-1]), dp[i-1][j-1]);
        }
    }
    return dp[N1][N2];
}
//*******************************************************
//Coin Change
int dp[1001];
int coins[] = {1, 5, 10, 25, 50};
dp[0] = 0;

for(int i = 1; i <= 74; i++) {
	int min = 1000001;
    for(int j = 0; j < 5; j++) {
		if(coins[j] <= i) {
			int m = dp[i - coins[j]] + 1;
            if(m < min) min = m;
        }
    }
    dp[i] = min;
}
//*******************************************************
//Counting ways to sum value 'x' using coins in set 'coins'
memo[0] = 1;
for(int i = 0; i < 5; i++) {
    int c = coins[i];
    for(int j = c; j <= x; j++) {
	memo[j] += memo[j - c];
    }
}
//*******************************************************
//Longest Increasing Subsequence - (LIS) O(Nlog(N))
void funcA(void) {
    int i, top = 0;

    stk[0] = INT_MIN;

    for (i = 0; i < N; ++i) {
        if (v[i] > stk[top]) {
            stk[++top] = v[i];
        } else {
            int low = 0, high = top;
            while (low <= high) {
                int mid = (low + high) >> 1;
                if (v[i] > stk[mid]) {
                    low = mid + 1;
                } else {
                    high = mid - 1;
                }
            }
            stk[low] = v[i];
        }
        in[i] = top;
    }
}
//*******************************************************
//*******************************************************
//Longest Increasing Subsequence - (LIS) O(N^2)
int lis(int array[], int n) {
    int best[n], prev[n];

    for(int i = 0; i < n; i++) {
        best[i] = 1;
        prev[i] = i;
    }

    for(int i = 1; i < n; i++) {
        for(int j = 0; j < i; j++) {
            if(array[i] > array[j] && best[i] < best[j] + 1) {
                best[i] = best[j] + 1; prev[i] = j;
            }
        }
    }
    int ans = 0; for(int i = 0; i < n; i++) ans = max(ans, best[i]);
    return ans;
}
//*******************************************************
//Longest Commom Subsequence - (LCS) O(N^2)
int lgs(string a, string b) {
	int n = a.size(), m = b.size();
	int[][] dp = new dp[n+1][m+1];

	for(int i = 0; i <= max(n, m); i++) {
		dp[i][0] = dp[0][i] = 0;
	}
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= m; j++) {
			if(a[i] == b[j]) {
				dp[i][j] = dp[i - 1][j - 1] + 1;
			} else {
				dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
			}
		}
	}
	return dp[n][m];
}
//*******************************************************
//Menor string que contem duas strings S1 e S2 como subsequencia

char S1[MAXS], S2[MAXS];
int dp[MAXS][MAXS];

memset(dp, 0, sizeof(dp));

for (i = 1; i <= N; i++) {
    for (j = 1; j <= M; j++) {
        if (S1[i - 1] == S2[j - 1]) {
            dp[i][j] = dp[i - 1][j - 1] + 1;
        } else {
           dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
        }
    }
}

string track(int i, int j) {
    if (i == 0 && j == 0) {
        return "";
    } else if (i == 0 && j > 0) {
        return track(i, j - 1) + S2[j - 1];
    } else if (i > 0 && j == 0) {
        return track(i - 1, j) + S1[i - 1];
    } else {
        if (S1[i - 1] == S2[j - 1]) {
            return track(i - 1, j - 1) + S1[i - 1];
        } else {
            if (dp[i][j - 1] > dp[i - 1][j]) {
                return track(i, j - 1) + S2[j - 1];
            } else {
                return track(i - 1, j) + S1[i - 1];
            }
        }
    }
}
//*******************************************************
//Checa por Palindromos
int T, N, dp[MAXN][MAXN];
char str[MAXN];

REP(i, N) {
    dp[i][i] = 1;
    if(i + 1 < N) dp[i][i + 1] = str[i] == str[i + 1];
}
for(int k = 2; k < N; k++) {
    REP(i, N - k) {
        dp[i][i + k] = dp[i + 1][i + k - 1] && str[i] == str[i + k];
    }
}
//*******************************************************
//Domino perfect matching - recursive
int a, b, i, j, k, n, ok, teste = 1, mem[7][7];

void rec(int now, int deep) {
    if(deep == n) {
        ok = 1;
        return;
    }
    for(j = 0; j <= 6; j++) {
        int i = j;
        if(mem[now][i]>0) {
            mem[now][i]--;
            mem[i][now]--;
            rec(i, deep + 1);
            if(ok == 1) return;
            mem[now][i]++;
            mem[i][now]++;
        }
    }
}

int main(void) {
    while(scanf("%d", &n) && n != 0) {
        memset(mem, 0, sizeof(mem));
        ok = 0;
        for(i = 0; i < n; i++) {
            scanf("%d%d", &a, &b);
            mem[a][b] += 1;
            mem[b][a] += 1;
        }
        for(k = 0; k <= 6; k++) {
            rec(k, 0);
            if(ok == 1) break;
        }
	// ok == 1, matching perfeito
    }
}
//*******************************************************
//Domino perfect matching - graph
void dfs(int x) {
    vis[x] = 1;
    for(int j = 0; j <= 6; j++) {
        if(vis[j] == 0 && mem[x][j] == 1) dfs(j);
    }
}

int main(void) {
    while(scanf("%d", &n) && n != 0) {
        memset(mem, 0, sizeof(mem)); memset(vis, 0, sizeof(vis)); memset(ct, 0, sizeof(ct));
        for(int i = 0; i < n; i++) {
            scanf("%d%d", &a, &b);
            ct[a] += 1;
            ct[b] += 1;
            mem[a][b] = 1;
            mem[b][a] = 1;
        }
        for(int i = 0; i <= 6; i++) {
            if(ct[i] > 0) {
                dfs(i); break;
            }
        }
        ok = 1;
        for(int i = 0; i <= 6; i++) {
            if(ct[i] > 0 && !vis[i]) {
                ok = 0;
            }
        }
        int o = 0;
        for(int i = 0; i <= 6; i++) {
            if(ct[i] % 2 == 1) o++;
        }
        printf("Teste %d\n%s\n\n", teste++, ok == 1 && (o == 0 || o == 2) ? "sim" : "nao");
    }
}
/* *************************** DATA STRUCTURES ***************************/
//*******************************************************
//Trie
struct Trie {
    Trie *child[MAXN];
    int prefixes;
    int words;

    Trie() {
        int i;
        prefixes = words = 0;
        for(i = 0; i < MAXN; i++) {
            child[i] = NULL;
        }
    }

    void addWord(string s, int pos = 0) {
        if(pos == s.size()) {
            words++;
            return;
        }

        int letter_pos = s[pos] - 'a';

        Trie *t = child[letter_pos];

        if(child[letter_pos] == NULL) {
            t = child[letter_pos] = new Trie();
            t->prefixes = 1;
        } else {
            t->prefixes = t->prefixes + 1;
        }
        t->addWord(s, pos + 1);
    }

    int count(string s, int pos = 0, int k = 0) {
        if(pos == s.size()) return k;
        Trie *t = child[s[pos] - 'a'];
        if(t == NULL) return 0;
        return t->count(s, pos + 1, (prefixes == t->prefixes) ? k: k + 1);
    }
};
//*******************************************************
//Union Find
struct UnionFind {
    int N, *id, *sz;

    UnionFind(int _N) {
        id = new int[_N];
        sz = new int[_N];
        for(int i = 0; i < _N; i++) {
            id[i] = i;
            sz[i] = 1;
        }
        N = _N;
    }
    int root(int i) {
        while(i != id[i]) {
            id[i] = id[id[i]];
            i = id[i];
        }
        return i;
    }
    bool find(int p, int q) {
        return root(p) == root(q);
    }
    void unite(int p, int q) {
        int i = root(p);
        int j = root(q);
        if(i == j) return;
        if(sz[i] < sz[j]) {
            id[i] = j; sz[j] += sz[i];
        } else {
            id[j] = i; sz[i] += sz[j];
        }
    }
};
//*******************************************************
Binary Indexed Tree(Fenwick Tree)
template<typename T = int>
struct FenwickTree {
    int N;
    T *values;

    FenwickTree(int N) {
        this->N = N;
        values = new T[N+5];

        for(int i = 1; i <= N; i++) values[i] = 0;
    }

    void increase(int index, T add) {
        while(index <= N) {
            values[index] += add;
            index += (index & -index);
        }
    }

    void update(int index, T new_value) {
        increase(index, new_value - readSingle(index));
    }

    T read(int index) {
        T sum = 0;

        while(index > 0) {
            sum += values[index];
            index -= (index & -index);
        }

        return sum;
    }

    T readSingle(int index){
        T sum = values[index];
        if(index > 0) {
            int z = index - (index & -index);
            index--;
            while(index != z) {
                sum -= values[index];
                index -= (index & -index);
            }
        }
        return sum;
    }

    T read(int low, int high) {
        return read(high) - read(low - 1);
    }

    void scale(T factor) {
        for(int i = 1; i <= N; i++) {
            values[i] /= factor;
        }
    }

    void power(T factor) {
        for(int i = 1; i <= N; i++) {
            values[i] *= factor;
        }
    }
};
//*******************************************************
Binary Indexed Tree 2D(Fenwick Tree 2D)
#include <iostream>
#include <vector>

using namespace std;

const int INF = 1000 * 1000 * 1000;

int n, m;
vector <vector <int>> t;

void init(int _n, int _m) {
    n = _n;
    m = _m;
    for(int i = 0; i < n; i++) {
        t.push_back(vector<int>(m, 0));
    }
}

int sum(int x, int y) {
    int result = 0;
    for (int i = x; i> = 0; i = (i & (i +1)) - 1) {
        for (int j = y; j> = 0; j = (j & (j +1)) - 1) {
            result += t[i][j];
        }
    }
    return result;
}

void inc (int x, int y, int delta) {
    for (int i = x; i <n; i = (i | (i +1))) {
        for (int j = y; j <m; j = (j | (j +1))) {
            t[i][j] += delta;
        }
    }
}

void update(int x, int y, int new_value) {
    for (int i = x; i> = 0; i = (i & (i +1)) - 1) {
        for (int j = y; j> = 0; j = (j & (j +1)) - 1) {
            t[i][j] = new_value;
        }
    }
}

int sum(int x1, int y1, int x2, int y2) {
    return sum(std::max(x1, x2), std::max(y1, y2)) - sum(std::min(x1, x2)-1, std::min(y1, y2)-1);
}
//*******************************************************
Simple Segment Tree
#include <iostream>
const int MAXN = 4;
const int INF = 10000010;

int a[10];

template<typename T>
struct SegmentTree {
    int N;
    T tree[3*MAXN];

    SegmentTree(int _N) {
        N = _N;
        for(int i = 0; i < 3*MAXN; i++) tree[i] = 0;
    }

    void build(T a[], int v, int tl, int tr) {
        if (tl == tr) {
            tree[v] = a[tl];
        } else {
            int mid = (tl + tr) / 2;
            build(a, v*2, tl, mid);
            build(a, v*2+1, mid+1, tr);
            tree[v] = tree[v*2] + tree[v*2+1];
        }
    }

    void build(T a[]) {
        build(a, 1, 0, N);
    }

    T sum(int v, int tl, int tr, int l, int r) {
        if (l > r) {
            return 0;
        }
        if(l == tl && r == tr) {
            return tree[v];
        }
        int mid = (tl + tr) / 2;
        return sum(v*2, tl, mid, l, min(r,mid)) + sum(v*2+1, mid+1, tr, max(l,mid+1), r);
    }

    T sum(int l, int r) {
        return sum(1, 0, N, l, r);
    }

    //Only works if you change the routine of build and update the tree
    T prod(int v, int tl, int tr, int l, int r) {
        if(l > r) {
            return 1;
        }
        if(l == tl && r == tr) {
            return tree[v];
        }
        int mid = (tl + tr) / 2;
        return prod(v*2, tl, mid, l, min(r,mid)) * prod(v*2+1, mid+1, tr, max(l,mid+1), r);
    }

    T prod(int l, int r) {
        return prod(1, 0, N, l, r);
    }

    void update_change(int v, int tl, int tr, int pos, T new_val) {
        if (tl == tr) {
            tree[v] = new_val;
        } else {
            int mid = (tl + tr) >> 1;
            if(pos <= mid) {
                update_change(v*2, tl, mid, pos, new_val);
            } else {
                update_change(v*2+1, mid+1, tr, pos, new_val);
            }
            tree[v] = tree[v*2] + tree[v*2+1];
        }
    }

    void update_change(int pos, T new_val) {
        update_change(1, 0, N, pos, new_val);
    }

    void update_add_single(int v, int tl, int tr, int pos, T add) {
        if (tl == tr) {
            tree[v] += add;
        } else {
            int mid = (tl + tr) >> 1;
            if(pos <= mid) {
                update_add_single(v*2, tl, mid, pos, add);
            } else {
                update_add_single(v*2+1, mid+1, tr, pos, add);
            }
            tree[v] = tree[v*2] + tree[v*2+1];
        }
    }

    void update_add_single(int pos, T add) {
        update_add_single(1, 0, N, pos, add);
    }

    void update_add_range_helper(int v, int tl, int tr, int l, int r, T add) {
        if(l > r) {
            return;
        }
        if(l == tl && tr == r) {
            tree[v] += add;
        } else {
            int mid = (tl + tr) >> 1;
            update_add_range_helper(v*2, tl, mid, l, min(r,mid), add);
            update_add_range_helper(v*2+1, mid+1, tr, max(l,mid+1), r, add);
            tree[v] = tree[v*2] + tree[v*2 + 1];
        }
    }

    void update_add_range(int v, int tl, int tr, int l, int r, int add) {
        if(tl == l && tr == r) {
            update_add_range_helper(v, tl, tr, l + 1, r - 1, add);
            update_add_single(v, tl, tr, l, add);
        } else {
            update_add_range_helper(v, tl, tr, l, r, add);
        }
    }

    void update_add_range(int l, int r, T add) {
        update_add_range(1, 0, N, l, r, add);
    }

};//*******************************************************
//Segment Tree which find max and min value of an interval [l, r)
#include <iostream>

using namespace std;

#define MAXN 1000
#define INF 10000000


int a[4*MAXN];
pair<int,int> t[4*MAXN];

pair<int,int> combine (pair<int,int> a, pair<int,int> b) {
	if (a.first > b.first)
		return a;
	if (b.first > a.first)
		return b;
	return make_pair (a.first, a.second + b.second);
}

pair<int,int> combine2(pair<int,int> a, pair<int,int> b) {
	if (a.first < b.first)
		return a;
	if (b.first < a.first)
		return b;
	return make_pair(a.first, a.second + b.second);
}

void build (int a[], int v, int tl, int tr) {
	if (tl == tr)
		t[v] = make_pair (a[tl], 1);
	else {
		int tm = (tl + tr) / 2;
		build (a, v*2, tl, tm);
		build (a, v*2+1, tm+1, tr);
		t[v] = combine (t[v*2], t[v*2+1]);
	}
}

pair<int,int> get_max (int v, int tl, int tr, int l, int r) {
	if (l > r)
		return make_pair (-INF, 0);
	if (l == tl && r == tr)
		return t[v];
	int tm = (tl + tr) / 2;
	return combine (
		get_max (v*2, tl, tm, l, min(r,tm)),
		get_max (v*2+1, tm+1, tr, max(l,tm+1), r)
	);
}

void update (int v, int tl, int tr, int pos, int new_val) {
	if (tl == tr)
		t[v] = make_pair (new_val, 1);
	else {
		int tm = (tl + tr) / 2;
		if (pos <= tm)
			update (v*2, tl, tm, pos, new_val);
		else
			update (v*2+1, tm+1, tr, pos, new_val);
		t[v] = combine (t[v*2], t[v*2+1]);
	}
}

//*******************************************************
//RMQ - Segment Tree
const int MAXN = 20000;
const int INF = 10000000;

//0-Based Range Minimum Query Segment Tree
template<typename T>
struct SegmentTreeRMQ {
    pair<T, T> t[MAXN*4];
    void build(T a[], int v, int tl, int tr) {
        if (tl == tr) t[v].first = a[tl];
        else {
            int tm = (tl + tr) >> 1;
            build (a, 2*v,tl,tm);
            build (a, 2*v+1,tm+1,tr);
            t[v].first = min (t[2*v].first,t[2*v+1].first);
        }
    }

    void update(int v, int tl, int tr, int l, int r, T value) {
        if (l > r) return;
        if (tl == l && r == tr) {
            t[v].second += value;
        } else {
            int tm = (tl + tr) >> 1;
            update (2*v,tl,tm,l,min(tm,r),value);
            update (2*v+1,tm+1,tr,max(tm+1,l),r,value);
            t[v].first = min (t[2*v].first + t[2*v].second,t[2*v+1].first + t[2*v+1].second);
        }
    }
    T rmq (int v, int tl, int tr, int l, int r) {
        if (l > r) {
            return INF;
        }
        if (tl == l && tr == r) {
            return t[v].first + t[v].second;
        } else {
            int tm = (tl + tr) >> 1;
            t[v].first = min (t[2*v].first + t[2*v].second,t[2*v+1].first + t[2*v+1].second);
            return min(rmq(2*v,tl,tm,l,min(tm,r)),rmq(2*v+1,tm+1,tr,max(l,tm+1),r))+t[v].second;
        }
    }
};
/*********************************************************************/
//Sliding RMQ in O(N)
void maxSlidingWindow(int A[], int n, int w, int B[]) {
  deque<int> Q;
  for (int i = 0; i < w; i++) {
    while (!Q.empty() && A[i] >= A[Q.back()])
      Q.pop_back();
    Q.push_back(i);
  }
  for (int i = w; i < n; i++) {
    B[i-w] = A[Q.front()];
    while (!Q.empty() && A[i] >= A[Q.back()])
      Q.pop_back();
    while (!Q.empty() && Q.front() <= i-w)
      Q.pop_front();
    Q.push_back(i);
  }
  B[n-w] = A[Q.front()];
}
/*********************************************************************/
/**************************** NUMBER THEORY ***************************/
/*********************************************************************/
//Contando a soma de todos os numeros do intervalo sum(a, b)
public static int sum(int a, int b) {
	a -= 1;
	return ((b * (b + 1)) / 2) - (((a) * (a + 1)) / 2);
}
//*******************************************************
//modpow(a, n, mod) - calcula a^n % mod de maneira eficiente
int modpow(int a, int n, int mod) {
	int res(1);
        while (n) {
                if (n&1)
                        res=(res*a)%mod;
                a=(a*1ll*a)%mod;
                n>>=1;
        }
        return res;
}
//*******************************************************
//Calculando n-th numero de fibonnaci em O(n)
static double inverseSqrt5 = 1 / sqrt(5);
static double phi = (1 + sqrt(5)) / 2;

ll func(ll n) {
    return (ll) floor(pow(phi, n) * inverseSqrt5 + 0.5);
}
//*******************************************************
//Exponenciação rápida O(log(n))
int binpow (int a, int n) {
	int res = 1;
	while (n) {
		if (n & 1)
			res *= a;
		a *= a;
		n >>= 1;
	}
	return res;
}
//*******************************************************
//Contando o numero de divisores inteiros de um determinado nume 'N' O(sqrt(N))
int ct(int n) {
    if(n == 1) return 1L;

    int x = (int) sqrt(n);
    int counter = 0;

    for(int i = 1; i <= x; i++) {
        if(n % i == 0) {
            counter += 2;
        }
    }
    if(x * x == n) counter -= 1;
    return counter;
}
//*******************************************************
//Checando se um numero é primo ou não
bool isPrime(long long n) {
    if(n <= 1) return false;
    if(n == 2) return true;
    if(n % 2 == 0) return false;

    long long m = (long long) sqrt(n);

    for(i = 3L; i <= m; i += 2L) {
        if(n % i == 0) {
            return false;
        }
    }
    return true;
}
//*******************************************************
//Crivo de Erastotenes Eficiente
const int N = 10000000;
int lp[N+1];
vector<int> pr;

for(int i = 2; i <= N; ++i) {
	if(lp[i] == 0) {
		lp[i] = i;
        pr.push_back(i);
    }
    for(int j = 0; j < (int) pr.size() && pr[j] <= lp[i] && i * pr[j] <= N; ++j) {
		lp[i * pr[j]] = pr[j];
    }
}
//*******************************************************
//Crivo de Erastotenes Comum - (Todos os numeros primes <= N)
bool sieve(int n) {
	bool prime[n+1];
	fill(prime, prime + n + 1,true);
	prime[0] = false;
	prime[1] = false;

	int m = (int) sqrt(n);

	for(int i = 2; i <= m; i++) {
		if(prime[i]) {
			for (int k=i*i; k<=n; k+=i) {
				prime[k]=false;
			}
		}
	}
	return prime;
}
//*******************************************************
//Problema de Josephus (ultimo a ser removido do circulo, removendo de D em D)
int N, D;

int func(void) {
    int r = 0, i = 2;

    while (i <= N) {
        r = (r + D) % i;
        i += 1;
    }

    return r + 1;
}
//*******************************************************
//Little Fermat Primarity test - (Testar se um numero é primo de maneira eficiente
BigInteger getRandomFermatBase(BigInteger n) {
	while(true) {
            final BigInteger a = new BigInteger (n.bitLength(), rand);
            if (BigInteger.ONE.compareTo(a) <= 0 && a.compareTo(n) < 0) {
                return a;
            }
        }
}

public static boolean checkPrime(BigInteger n, int maxIterations) {
	if(n.equals(BigInteger.ONE)) {
            return false;
	}
        for (int i = 0; i < maxIterations; i++) {
            BigInteger a = getRandomFermatBase(n);
            a = a.modPow(n.subtract(BigInteger.ONE), n);

            if (!a.equals(BigInteger.ONE)) {
                return false;
		}
        }
        return true;
}
//*******************************************************
//Soma de todos os divisores de um numero
vector<int> primes;

void build(void) {
    vector<int> memo(N+5, 1); memo[0] = memo[1] = 0;

    for(int i = 2; i <= (int) sqrt(N); i++) if(memo[i] == 1) {
        for(int j = i * i; j <= N; j += i) {
            memo[j] = 0;
        }
    }

    for(int i = 2; i <= N; i++) if(memo[i]) primes.push_back(i);
}

void mount(int x) {
    vector<int> fact;
    int base = 0, other = x, mult = 1;
    while(x > 1) {
        int cnt = 0;
        while(base < primes.size() && x % primes[base] == 0) {
            x /= primes[base];
            cnt += 1;
        }
        if(cnt) {
            mult *= (((int) pow(primes[base], cnt + 1) - 1) / (int) (primes[base] - 1));
        }
        base += 1;
    }
    sum[other] = mult - other;
}
//*******************************************************
//Subset-Sum -> (G = O valor total sendo testado, N = numero de valores disponiveis no array 'values'
int values[n];
bool subsetSum(int n, int g) {
    for(j = 0; j <= g; j++) sub[j] = 0;
    sub[0] = 1;
    for(j = 0; j < n; j++) if(values[j] != g) {
        for(int k = g; k >= values[j]; k--) {
            sub[k] |= sub[k - values[j]];
        }
    }
    return sub[g];
}
//*******************************************************
//GCD - Maximo Divisor Comum
int gcd(int a, int b) {
	if(b == 0) return a;
	return gcd(b, a % b);
}
//*******************************************************
//LCM - Minimo Multiplo Comum
int lcm(int a, int b) {
	return a * b / gcd(a, b);
}
//*******************************************************
//Euler Phi Function (Get coprime numbers)
//*******************************************************
#include <iostream>
#include <limits.h>
#include <cstdlib>
#include <cmath>
using namespace std;

const int N1 = 50001, N2 = 5133;
bool isPrime[N1];
int prime[N2], nPrime, totient[N1];

void sieveAndTotient() {
    // reset
    for (int i = 0; i < N1; ++i)
        totient[i] = i;
    isPrime[0] = isPrime[1] = false;
    for (int i = 3; i < N1; i += 2)
        isPrime[i] = true;
    for (int i = 4; i < N1; i += 2)
        isPrime[i] = false;
    nPrime = 0;
    // 2
    // update for 2
    prime[nPrime++] = 2;
    for (int j = 2; j < N1; j += 2) {
        isPrime[j] = false;
        // totient for 2
        totient[j] -= totient[j] / 2;
    }
    isPrime[2] = true;
    // odds
    for (int i = 3; i < N1; i += 2)
        if (isPrime[i]) {
            // update for i
            prime[nPrime++] = i;
            if (i < INT_MAX)
                for (int j = i; j < N1; j += i) {
                    isPrime[j] = false;
                    // totient for i
                    totient[j] -= totient[j] / i;
                }
            isPrime[i] = true;
        }
}

int main() {
    sieveAndTotient();
    int in;
    while (cin >> in)
        cout << totient[in] << endl;
    return 0;
}
//*******************************************************
//Euler Phi Function (Get coprime numbers) - Faster
 int fi(int n)
     {
       int result = n;
       for(int i=2;i*i <= n;i++)
       {
         if (n % i == 0) result -= result / i;
         while (n % i == 0) n /= i;
       }
       if (n > 1) result -= result / n;
       return result;
     }

//*******************************************************
//Fast method to get factorial of N MOD P, in O(N log(P))
//*******************************************************
int factmod (int n, int p) {
	int res = 1;
	while (n > 1) {
		res = (res * ((n/p) % 2 ? p-1 : 1)) % p;
		for (int i=2; i<=n%p; ++i)
			res = (res * i) % p;
		n /= p;
	}
	return res % p;
}
//*******************************************************
//Euler phi function using less memory
//*******************************************************
#include <cstdio>
using namespace std;

typedef long long int64;

int64 totient(int64 n) {
    if (n == 1)
        return 1ll;
    int64 out = n;
    // 2
    if (n % 2 == 0) {
        out -= out / 2;
        do
            n /= 2;
        while (n % 2 == 0);
    }
    // odds
    for (int i = 3; i * i <= n; i += 2)
        if (n % i == 0) {
            out -= out / i;
            do
                n /= i;
            while (n % i == 0);
        }
    //
    if (n > 1)
        out -= out / n;
    return out;
}

int main() {
    int64 n;
    scanf("%lld", &n);
    printf("%lld\n", totient(n));
    return 0;
}
/* ***************************** BASE TRANSFORMATIONS ********************* */
//Chega se o digito corresponde a base numerica indicada
boolean isFromBase(char digit, int base) {
	if (digit >= 'A' && digit - 'A' + 10 >= base) {
		return false;
	} else if (digit < 'A' && digit - '0' >= base) {
		return false;
	} else {
		return true;
	}
}

//Qualuqer base para decimal
public int anyBaseToDec(String num, int fromBase) {
	int ans = 0;
	int n = num.length();
	for (int i = 0; i < num.length(); i++) {
		if (!isFromBase(num.charAt(i), fromBase)) return -1;
		if (num.charAt(i) >= 'A') {
			ans += (num.charAt(i) + 10 - 'A') * (modpow(fromBase, n - i - 1));
		} else {
			ans += (num.charAt(i) - '0') * (modpow(fromBase, n - i - 1));
		}
	}
	return ans;
}


//Decimal para outras bases
public String decToOthers(int value, int toBase) {
	if (value == 0) return "0";
	String ans = "";
	while (value > 0) {
		int aux = (value % toBase);
		if (aux > 9) {
			ans = (char) ('A' - 9 + aux - 1) + ans;
		} else {
			ans = (char) (aux + '0') + ans;
		}
		value /= toBase;
	}
	return ans;
}
