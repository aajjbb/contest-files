//Point structure
//Piece of code stracted from the hichhikin guide to programming
//start from any initial values.

const double PI = 2.0*acos(0.0);
const double EPS = 1e-9; //too small/big?????
struct PT {
	double x,y;
	double length() {
		return sqrt(x*x+y*y);
	}
	int normalize() {
		double l = length();
		if(fabs(l)<EPS) return -1;
		x/=l; y/=l;
		return 0;
	}
	PT operator-(PT a) {
		PT r;
		r.x=x-a.x; r.y=y-a.y;
		return r;
	}
	PT operator+(PT a){
		PT r;
		r.x=x+a.x; r.y=y+a.y;
		return r;
	}
	PT operator*(double sc) {
		PT r;
		r.x=x*sc; r.y=y*sc;
		return r;
	}
};
bool operator<(const PT& a,const PT& b) {
	if(fabs(a.x-b.x)<EPS) return a.y<b.y;
	return a.x<b.x;
}
double dist(PT& a, PT& b){
	return sqrt((a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y));
}
double dot(PT& a, PT& b) {
	return(a.x*b.x+a.y*b.y);
}
r.x=x*sc; r.y=y*sc;
// Areas
// ===============================================================
double trap(PT a, PT b) {
	return (0.5*(b.x - a.x)*(b.y + a.y));
}
double area(vector<PT> &vin) {
	// Area of a simple polygon, not neccessary convex
	int n = vin.size();
	double ret = 0.0;
	for(int i = 0; i < n; i++) {
		ret += trap(vin[i], vin[(i+1)%n]);
	}
	return fabs(ret);
}
double peri(vector<PT> &vin) {
	// Perimeter of a simple polygon, not neccessary convex
	int n = vin.size();
	double ret = 0.0;
	for(int i = 0; i < n; i++) {
		ret += dist(vin[i], vin[(i+1)%n]);
	}
	return ret;
}
double triarea(PT a, PT b, PT c) {
	//Triangle area
	return fabs(trap(a,b)+trap(b,c)+trap(c,a));
}
double height(PT a, PT b, PT c) {
	// height from a to the line bc
	double s3 = dist(c, b);
	double ar = triarea(a,b,c);
	return (2.0*ar/s3);
}
//***************************************
//Check wheter a polygon is convex
int sideSign(PT& p1,PT& p2,PT& p3) {
	// which side is p3 to the line p1->p2? returns: 1 left, 0 on, -1 right
	double sg = (p1.x-p3.x)*(p2.y-p3.y)-(p1.y - p3.y)*(p2.x-p3.x);
	if (fabs(sg)<EPS) return 0;
	if (sg>0) return 1;
	return -1;
}
int isConvex(vector<PT>& v) {
	// test whether a simple polygon is convex
	// return 0 if not convex, 1 if strictly convex,
	// 2 if convex but there are points unnecesary
	// this function does not work if the polycon is self intersecting
	// in that case, compute the convex hull of v, and see if both have the same area
	int i,j,k;
	int c1=0; int c2=0; int c0=0;
	int n=v.size();
	for(i = 0;i < n; i++) {
		j= (i+1)%n;
		k= (j+1)%n;
		int s = sideSign(v[i], v[j], v[k]);
		if (s == 0) c0++;
		if (s > 0) c1++;
		if (s < 0) c2++;
	}
	if(c1 && c2) return 0;
	if(c0) return 2;
	return 1;
}
// ====================================================
// Points and Lines
// ====================================================
int intersection( PT p1, PT p2, PT p3, PT p4, PT &r) {
	// two lines given by p1->p2, p3->p4 r is the intersection point
	// return -1 if two lines are parallel
	double d = (p4.y - p3.y)*(p2.x-p1.x) - (p4.x - p3.x)*(p2.y - p1.y);
	if( fabs( d ) < EPS ) return -1;
	// might need to do something special!!!
	double ua, ub;
	ua = (p4.x - p3.x)*(p1.y-p3.y) - (p4.y-p3.y)*(p1.x-p3.x);
	ua /= d;
	// ub = (p2.x - p1.x)*(p1.y-p3.y) - (p2.y-p1.y)*(p1.x-p3.x);
	//ub /= d;
	r = p1 + (p2-p1)*ua;
	return 0;
}

void closestpt( PT p1, PT p2, PT p3, PT &r) {
	// the closest point on the line p1->p2 to p3
	if (fabs( triarea( p1, p2, p3)) < EPS) {
		r = p3;
		return;
	}
	PT v = p2-p1;
	v.normalize();
	double pr; // inner product
	pr = (p3.y-p1.y)*v.y + (p3.x-p1.x)*v.x;
	r = p1+v*pr;
}
int hcenter( PT p1, PT p2, PT p3, PT& r) {
	// point generated by altitudes
	if (triarea( p1, p2, p3 ) < EPS) return -1;
	PT a1, a2;
	closestpt( p2, p3, p1, a1 );
	closestpt( p1, p3, p2, a2 );
	intersection( p1, a1, p2, a2, r );
	return 0;
}
int center( PT p1, PT p2, PT p3, PT& r) {
	// point generated by circumscribed circle
	if (triarea( p1, p2, p3 ) < EPS) return -1;
	PT a1, a2, b1, b2;
	a1 = (p2+p3)*0.5;
	a2 = (p1+p3)*0.5;
	b1.x = a1.x - (p3.y-p2.y);
	b1.y = a1.y + (p3.x-p2.x);
	b2.x = a2.x - (p3.y-p1.y);
	b2.y = a2.y + (p3.x-p1.x);
	intersection(a1, b1, a2, b2, r);
	return 0;
}
